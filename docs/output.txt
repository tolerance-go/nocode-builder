Welcome to the Stately and XState docs​
Stately.ai is a visual software modeling platform for modeling your app & business logic as state machines/statecharts and actors, and scales to any level of complexity.
XState is a best-in-class open source library
for orchestrating and managing state in JavaScript and TypeScript apps.
Get startedJump straight into learning how to use Stately Studio editor, starting with states.Stately Studio overviewFind out more about Stately
Studio’s visual editor and collaborating with your team using Stately
Studio’s premium features.Learn state machines and statechartsWith our no-code introduction.Learn XStateGet started with our JavaScript and
TypeScript library for state machines and statecharts.
View the Default machine machine in Stately Studio.
Stately Studio or XState?​
Stately Studio and XState are most powerful when used together. Use Stately Studio’s visual editor to collaboratively model your app logic and use XState to integrate that logic into your codebase.
You can also use XState in your codebase without Stately Studio, and you’re welcome to use Stately Studio if you’re not yet familiar with XState.
Who is Stately?​

We’re Stately, a small team founded by David Khourshid, the creator of XState. Stately is building Stately Studio, where you can visualize your application logic and collaborate with your whole team.

Quick startThis quick start guide will help you get started with XState and Stately Studio. You will learn how to create a state machine, create an actor from that state machine, send events to that actor, and observe the state changes.
The fastest way to start with Stately Studio is to go to state.new. There, you’ll find a starter machine with all the statechart basics ready for you to edit. Read more about Stately Studio.
Installing XState v5​
XState is a visual state management and orchestration library for JavaScript and TypeScript.
Install the XState v5 using your preferred package manager:
npmpnpmyarnnpm install xstatepnpm install xstateyarn add xstate
XState v5 requires TypeScript version 5.0 or greater.For best results, use the latest TypeScript version. Read more about XState and TypeScript
Create a machine​
In XState, a machine is an object that contains all the logic for an actor. In this example, we will create a simple toggle machine that can be in one of two states: Active or Inactive. The toggle event will toggle the state between Active and Inactive.
import { createMachine } from 'xstate';const toggleMachine = createMachine({  id: 'toggle',  initial: 'Inactive',  states: {    Inactive: {      on: { toggle: 'Active' },    },    Active: {      on: { toggle: 'Inactive' },    },  },});
Read our introduction to state machines and statecharts to familiarize yourself with the concepts.
Create an actor and send events​
Machine logic can be used to create an actor. An actor is a running process that can receive messages (events), send messages and change its behavior based on the messages it receives.
import { createMachine, createActor } from 'xstate';const toggleMachine = createMachine({  // Machine code from above});// Create an actor that you can send events to.// Note: the actor is not started yet!const actor = createActor(toggleMachine);// Subscribe to snapshots (emitted state changes) from the actoractor.subscribe((snapshot) => {  console.log('Value:', snapshot.value);});// Start the actoractor.start(); // logs 'Inactive'// Send eventsactor.send({ type: 'toggle' }); // logs 'Active'actor.send({ type: 'toggle' }); // logs 'Inactive'
Use delayed transitions​
Delayed transitions are transitions that automatically happen after a specified interval of time.
export const toggleMachine = createMachine({  id: 'toggle',  initial: 'Inactive',  states: {    Inactive: {      on: { toggle: 'Active' },    },    Active: {      on: { toggle: 'Inactive' },      after: { 2000: 'Inactive' },    },  },});
Handle context data​
Context is how you store data in a state machine actor.
import { assign, createMachine } from 'xstate';export const toggleMachine = createMachine({  id: 'toggle',  context: { count: 0 },  initial: 'Inactive',  states: {    Inactive: {      on: { toggle: 'Active' },    },    Active: {      entry: assign({        count: ({ context }) => context.count + 1      }),      on: { toggle: 'Inactive' },      after: { 2000: 'Inactive' },    },  },});
Add input​
Input is how initial data can be provided to a machine actor.
Guards are used to conditionally allow or disallow transitions.
import { assign, createMachine } from 'xstate';export const toggleMachine = createMachine({  id: 'toggle',  context: ({ input }) => ({    count: 0,    maxCount: input.maxCount  }),  initial: 'Inactive',  states: {    Inactive: {      on: {        toggle: {          // Only trigger toggle transition if count is less than maxCount          guard: ({ context }) => context.count < context.maxCount,          target: 'Active'        }      }    },    Active: {      entry: assign({        count: ({ context }) => context.count + 1      }),      on: { toggle: 'Inactive' },      after: { 2000: 'Inactive' },    },  },});const actor = createActor(toggleMachine, {  input: { maxCount: 10 }});actor.subscribe(snapshot => {  console.log('State:', snapshot.value);});actor.start();actor.send({ type: 'toggle' });
Use your machine with a framework​

Check out all our packages
Find out more about the @xstate/react package

import { useMachine } from '@xstate/react';import { toggleMachine } from './toggleMachine';const App = () => {  const [state, send] = useMachine(toggleMachine);  return (    <div>      <div>Value: {state.value}</div>      <button onClick={() => send({ type: 'toggle' })}>        Toggle      </button>    </div>  );};

Use the XState v5 templates
Find more examples
Migrate from XState V4 to XState V5


Installation
XState has zero dependencies and runs anywhere that JavaScript runs. You can install XState using your favorite package manager, like npm, pnpm, or yarn.
npmpnpmyarnnpm install xstatepnpm install xstateyarn add xstate
CDN​
You can also import XState from various CDNs:

esm.run:

import { createMachine, createActor } from 'https://esm.run/xstate';

esm.sh:

import { createMachine, createActor } from 'https://esm.sh/xstate';

Skypack:

import { createMachine, createActor } from 'https://cdn.skypack.dev/xstate';

Migrating from XState v4 to v5The guide below explains how to migrate from XState version 4 to version 5. Migrating from XState v4 to v5 should be a straightforward process. If you get stuck or have any questions, please reach out to the Stately team on our Discord.
Read David’s blog post on the launch of XState v5.
This guide is for developers who want to update their codebase from v4 to v5 and should also be valuable for any developers wanting to know the differences between v4 and v5.
Prefer video? Watch our XState v5 webinar on YouTube.
XState v5 and TypeScript​
XState v5 and its related libraries are written in TypeScript, and utilize complex types to provide the best type safety and inference possible for you. XState v5 requires TypeScript version 5.0 or greater. For best results, use the latest TypeScript version.
Follow these guidelines to ensure that your TypeScript project is ready to use XState v5:


Use the latest version of TypeScript, version 5.0 or greater (required)
npm install typescript@latest --save-dev


Set strictNullChecks to true in your tsconfig.json file. This will ensure that our types work correctly and will also help catch errors in your code (strongly recommended)
// tsconfig.json{  "compilerOptions": {    // ...    "strictNullChecks": true    // or set `strict` to true, which includes `strictNullChecks`    // "strict": true  }}


Set skipLibCheck to true in your tsconfig.json file (recommended)


Creating machines and actors​
Use createMachine(), not Machine()​
Breaking change
The Machine(config) function is now called createMachine(config):
XState v5XState v4import { createMachine } from 'xstate';const machine = createMachine({  // ...});// ❌ DEPRECATEDimport { Machine } from 'xstate';const machine = Machine({  // ...});
Use createActor(), not interpret()​
Breaking change
The interpret() function has been renamed to createActor():
XState v5XState v4import { createMachine, createActor } from 'xstate';const machine = createMachine(/* ... */);// ✅const actor = createActor(machine, {  // actor options});import { createMachine, interpret } from 'xstate';const machine = createMachine(/* ... */);// ❌ DEPRECATEDconst actor = interpret(machine, {  // actor options});
Use machine.provide(), not machine.withConfig()​
Breaking change
The machine.withConfig() method has been renamed to machine.provide():
XState v5XState v4// ✅const specificMachine = machine.provide({  actions: {    /* ... */  },  guards: {    /* ... */  },  actors: {    /* ... */  },  // ...});// ❌ DEPRECATEDconst specificMachine = machine.withConfig({  actions: {    /* ... */  },  guards: {    /* ... */  },  services: {    /* ... */  },  // ...});
Set context with input, not machine.withContext()​
Breaking change
The machine.withContext(...) method can no longer be used, as context can no longer be overridden directly. Use input instead:
XState v5XState v4// ✅const machine = createMachine({  context: ({ input }) => ({    actualMoney: Math.min(input.money, 42),  }),});const actor = createActor(machine, {  input: {    money: 1000,  },});// ❌ DEPRECATEDconst machine = createMachine({  context: {    actualMoney: 0,  },});const moneyMachine = machine.withContext({  actualMoney: 1000,});
Actions ordered by default, predictableActionArguments no longer needed​
Breaking change
Actions are now in predictable order by default, so the predictableActionArguments flag is no longer required. Assign actions will always run in the order they are defined.
XState v5XState v4// ✅const machine = createMachine({  entry: [    ({ context }) => {      console.log(context.count); // 0    },    assign({ count: 1 }),    ({ context }) => {      console.log(context.count); // 1    },    assign({ count: 2 }),    ({ context }) => {      console.log(context.count); // 2    },  ],});// ❌ DEPRECATEDconst machine = createMachine({  predictableActionArguments: true,  entry: [    (context) => {      console.log(context.count); // 0    },    assign({ count: 1 }),    (context) => {      console.log(context.count); // 1    },    assign({ count: 2 }),    (context) => {      console.log(context.count); // 2    },  ],});
The spawn() function has been removed​
Instead of using the imported spawn() function to create actors inside assign(...) actions:

Use the spawnChild(...) action creator (preferred)
Or use the spawn(...) method from the first argument passed to the assigner function inside of assign(...) actions (useful if you need the actor ref in context)

Read the documentation on spawning actors for more information.
XState v5XState v4// ✅import { spawnChild, assign } from 'xstate';// Spawning a direct child:const machine1 = createMachine({  // ...  entry: spawnChild('someChildLogic', {    id: 'someChild',  })});// Spawning a child with the actor ref in `context`:const machine2 = createMachine({  // ...  entry: assign({    child: ({ spawn }) => spawn('someChildLogic')  })});// ❌import { assign, spawn } from 'xstate';const machine = createMachine({  // ...  entry: assign({    child: () => spawn('someChildLogic')  })});
Use getNextSnapshot(…) instead of machine.transition(…)​
The machine.transition(…) method now requires an "actor scope" for the 3rd argument, which is internally created by createActor(…). Instead, use getNextSnapshot(…) to get the next snapshot from some actor logic based on the current snapshot and event:
XState v5XState v4// ✅import {  createMachine,  getNextSnapshot} from 'xstate';const machine = createMachine({  // ...});const nextState = getNextSnapshot(  machine,   machine.resolveState({ value: 'green' }),  { type: 'timer' });nextState.value; // yellow// ❌import { createMachine } from 'xstate';const machine = createMachine({  // ...});const nextState = machine.transition(  'green',  { type: 'timer' });nextState.value; // yellow
Send events explictly instead of using autoForward​
The autoForward property on invoke configs has been removed. Instead, send events explicitly.
In general, it's not recommended to forward all events to an actor. Instead, only forward the specific events that the actor needs.
XState v5XState v4// ✅const machine = createMachine({  // ...  invoke: {    src: 'someSource',    id: 'someId'  },  always: {    // Forward events to the invoked actor    // This will not cause an infinite loop in XState v5    actions: sendTo('someId', ({ event }) => event)  }});// ❌const machine = createMachine({  // ...  invoke: {    src: 'someSource',    id: 'someId'    autoForward: true // deprecated  }});
States​
Use state.getMeta() instead of state.meta​
Breaking change
The state.meta property has been renamed to state.getMeta():
XState v5XState v4// ✅state.getMeta();// ❌ DEPRECATEDstate.meta;
The state.toStrings() method has been removed​
Breaking change
import { type StateValue } from 'xstate';export function getStateValueStrings(stateValue: StateValue): string[] {  if (typeof stateValue === 'string') {    return [stateValue];  }  const valueKeys = Object.keys(stateValue);  return valueKeys.concat(    ...valueKeys.map((key) =>      getStateValueStrings(stateValue[key]!).map((s) => key + '.' + s)    )  );}// ...const stateValueStrings = getStateValueStrings(stateValue);// e.g. ['green', 'yellow', 'red', 'red.walk', 'red.wait', …]
Use state._nodes instead of state.configuration​
Breaking change
The state.configuration property has been renamed to state._nodes:
XState v5XState v4// ✅state._nodes;// ❌ DEPRECATEDstate.configuration;
Read events from inspection API instead of state.events​
The state.events property has been removed, because events are not part of state, unless you explicitly add them to the state's context. Use the inspection API to observe events instead, or add the event explicitly to the state's context:
XState v5XState v5 (context)XState v4// ✅import { createActor } from 'xstate';import { someMachine } from './someMachine';const actor = createActor(someMachine, {  inspect: (inspEvent) => {    if (inspEvent.type === '@xstate.event') {      console.log(inspEvent.event);    }  }});// ✅import { setup, createActor } from 'xstate';const someMachine = setup({  // ...  actions: {    recordEvent: assign({      event: ({ event }) => event    })  }}).createMachine({  context: { event: undefined },  on: {    someEvent: {      // ...       actions: ['recordEvent']    }  }});const someActor = createActor(someMachine);someActor.subscribe(snapshot => {  console.log(snapshot.context.event);});// ❌ DEPRECATEDimport { interpret } from 'xstate';import { someMachine } from './someMachine';const actor = interpret(someMachine);actor.subscribe(state => {  console.log(state.event); // Removed});
Events and transitions​
Implementation functions receive a single argument​
Breaking change
Implementation functions now take in a single argument: an object with context, event, and other properties.
XState v5XState v4// ✅const machine = createMachine({  entry: ({ context, event }) => {    // ...  },});// ❌ DEPRECATEDconst machine = createMachine({  entry: (context, event) => {    // ...  },});
send() is removed; use raise() or sendTo()​
Breaking change
The send(...) action creator is removed. Use raise(...) for sending events to self or sendTo(...) for sending events to other actors instead.
Read the documentation on the sendTo action and raise action for more information.
XState v5XState v4// ✅const machine = createMachine({  // ...  entry: [    // Send an event to self    raise({ type: 'someEvent' }),    // Send an event to another actor    sendTo('someActor', { type: 'someEvent' }),  ],});// ❌ DEPRECATEDconst machine = createMachine({  // ...  entry: [    // Send an event to self    send({ type: 'someEvent' }),    // Send an event to another actor    send({ type: 'someEvent' }, { to: 'someActor' }),  ],});
Pre-migration tip: Update v4 projects to use sendTo or raise instead of send.
Use enqueueActions() instead of pure() and choose()​
The pure() and choose() methods have been removed. Use enqueueActions() instead.
For pure() actions:
XState v5XState v4// ✅entry: [  enqueueActions(({ context, event, enqueue }) => {    enqueue('action1');    enqueue('action2');  })];// ❌ DEPRECATEDentry: [  pure(() => {    return [      'action1',      'action2'    ]  })];
For choose() actions:
XState v5XState v4// ✅entry: [  enqueueActions(({ enqueue, check }) => {    if (check('someGuard')) {      enqueue('action1');      enqueue('action2');    }  })];// ❌ DEPRECATEDentry: [  choose([    {      guard: 'someGuard',      actions: ['action1', 'action2']    }  ]),];
actor.send() no longer accepts string types​
Breaking change
String event types can no longer be sent to, e.g., actor.send(event); you must send an event object instead:
XState v5XState v4// ✅actor.send({ type: 'someEvent' });// ❌ DEPRECATEDactor.send('someEvent');
Pre-migration tip: Update v4 projects to pass an object to .send().
state.can() no longer accepts string types​
Breaking change
String event types can no longer be sent to, e.g., state.can(event); you must send an event object instead:
XState v5XState v4// ✅state.can({ type: 'someEvent' });// ❌ DEPRECATEDstate.can('someEvent');
Guarded transitions use guard, not cond​
Breaking change
The cond transition property for guarded transitions is now called guard:
XState v5XState v4// ✅const machine = createMachine({  on: {    someEvent: {      guard: 'someGuard',      target: 'someState',    },  },});// ❌ DEPRECATEDconst machine = createMachine({  on: {    someEvent: {      // renamed to `guard` in v5      cond: 'someGuard',      target: 'someState',    },  },});
Use params to pass params to actions & guards​
Breaking change
Properties other than type on action objects and guard objects should be nested under a params property; { type: 'someType', message: 'hello' } becomes { type: 'someType', params: { message: 'hello' }}. These params are then passed to the 2nd argument of the action or guard implementation:
XState v5XState v4// ✅const machine = createMachine({  entry: {    type: 'greet',    params: {      message: 'Hello world',    },  },  on: {    someEvent: {      guard: { type: 'isGreaterThan', params: { value: 42 } },    },  },}).provide({  actions: {    greet: ({ context, event }, params) => {      console.log(params.message); // 'Hello world'    },  },  guards: {    isGreaterThan: ({ context, event }, params) => {      return event.value > params.value;    },  },});// ❌ DEPRECATEDconst machine = createMachine(  {    entry: {      type: 'greet',      message: 'Hello world',    },    on: {      someEvent: {        cond: { type: 'isGreaterThan', value: 42 },      },    },  },  {    actions: {      greet: (context, event, { action }) => {        console.log(action.message); // 'Hello world'      },    },    guards: {      isGreaterThan: (context, event, { guard }) => {        return event.value > guard.value;      },    },  },);
Pre-migration tip: Update action and guard objects on v4 projects to move properties (other than type) to a params object.
Use wildcard * transitions, not strict mode​
Breaking change
Strict mode is removed. If you want to throw on unhandled events, you should use a wildcard transition:
XState v5XState v4// ✅const machine = createMachine({  on: {    knownEvent: {      // ...    },    '*': {      // unknown event      actions: ({ event }) => {        throw new Error(`Unknown event: ${event.type}`);      },    },  },});const actor = createActor(machine);actor.subscribe({  error: (err) => {    console.error(err);  }});actor.start();actor.send({ type: 'unknownEvent' });// ❌ DEPRECATEDconst machine = createMachine({  strict: true,  on: {    knownEvent: {      // ...    },  },});const service = interpret(machine);service.send({ type: 'unknownEvent' });
Use explicit eventless (always) transitions​
Breaking change
Eventless (“always”) transitions must now be defined through the always: { ... } property of a state node; they can no longer be defined via an empty string:
XState v5XState v4// ✅const machine = createMachine({  // ...  states: {    someState: {      always: {        target: 'anotherState',      },    },  },});// ❌ DEPRECATEDconst machine = createMachine({  // ...  states: {    someState: {      on: {        '': {          target: 'anotherState',        },      },    },  },});
Pre-migration tip: Update v4 projects to use always for eventless transitions.
Use reenter: true, not internal: false​
Breaking change
internal: false is now reenter: true
External transitions previously specified with internal: false are now specified with reenter: true:
XState v5XState v4// ✅const machine = createMachine({  // ...  on: {    someEvent: {      target: 'sameState',      reenter: true,    },  },});// ❌ DEPRECATEDconst machine = createMachine({  // ...  on: {    someEvent: {      target: 'sameState',      internal: false,    },  },});
Transitions are internal by default, not external​
Breaking change
All transitions are internal by default. This change is relevant for transitions defined on state nodes with entry or exit actions, invoked actors, or delayed transitions (after). If you relied on the previous XState v4 behavior where transitions implicitly re-entered a state node, use reenter: true:
XState v5XState v4// ✅const machine = createMachine({  // ...  states: {    compoundState: {      entry: 'someAction',      on: {        someEvent: {          target: 'compoundState.childState',          // Reenters the `compoundState` state,          // just like an external transition          reenter: true,        },        selfEvent: {          target: 'childState',          reenter: true        }      },      initial: 'childState',      states: {        childState: {},      },    },  },});// ❌ DEPRECATEDconst machine = createMachine({  // ...  states: {    compoundState: {      entry: 'someAction',      on: {        someEvent: {          // implicitly external          target: 'compoundState.childState', // non-relative target        },        selfEvent: {          target: 'compoundState'        }      },      initial: 'childState',      states: {        childState: {},      },    },  },});
XState v5XState v4// ✅const machine = createMachine({  // ...  states: {    compoundState: {      after: {        1000: {          target: 'compoundState.childState',          reenter: true, // make it external explicitly!        },      },      initial: 'childState',      states: {        childState: {},      },    },  },});// ❌ DEPRECATEDconst machine = createMachine({  // ...  states: {    compoundState: {      after: {        1000: {          // implicitly external          target: 'compoundState.childState', // non-relative target        },      },      initial: 'childState',      states: {        childState: {},      },    },  },});
Child state nodes are always re-entered​
Breaking change
Child state nodes are always re-entered when they are targeted by transitions (both external and internal) defined on compound state nodes. This change is relevant only if a child state node has entry or exit actions, invoked actors, or delayed transitions (after). Add a stateIn guard to prevent undesirable re-entry of the child state:
XState v5XState v4// ✅const machine = createMachine({  // ...  states: {    compoundState: {      on: {        someEvent: {          guard: not(stateIn({ compoundState: 'childState' })),          target: '.childState',        },      },      initial: 'childState',      states: {        childState: {          entry: 'someAction',        },      },    },  },})// ❌ DEPRECATEDconst machine = createMachine({  // ...  states: {    compoundState: {      on: {        someEvent: {          // Implicitly internal; childState not re-entered          target: '.childState',        },      },      initial: 'childState',      states: {        childState: {          entry: 'someAction',        },      },    },  },});
Use stateIn() to validate state transitions, not in​
Breaking change
The in: 'someState' transition property is removed. Use guard: stateIn(...) instead:
XState v5XState v4// ✅const machine = createMachine({  on: {    someEvent: {      guard: stateIn({ form: 'submitting' }),      target: 'someState',    },  },});// ❌ DEPRECATEDconst machine = createMachine({  on: {    someEvent: {      in: '#someMachine.form.submitting'      target: 'someState',    },  },});
Use actor.subscribe() instead of state.history​
Breaking change
The state.history property is removed. If you want the previous snapshot, you should maintain that via actor.subscribe(...) instead.
XState v5XState v4// ✅let previousSnapshot = actor.getSnapshot();actor.subscribe((snapshot) => {  doSomeComparison(previousSnapshot, snapshot);  previousSnapshot = snapshot;});// ❌ DEPRECATEDactor.subscribe((state) => {  doSomeComparison(state.history, state);});
Pre-migration tip: Update v4 projects to track history using actor.subscribe().
Actions can throw errors without escalate​
Breaking change
The escalate action creator is removed. In XState v5 actions can throw errors, and they will propagate as expected. Errors can be handled using an onError transition.
XState v5XState v4// ✅const childMachine = createMachine({  // This will be sent to the parent machine that invokes this child  entry: () => {    throw new Error('This is some error')  }});const parentMachine = createMachine({  invoke: {    src: childMachine,    onError: {      actions: ({ context, event }) => {        console.log(event.error);        //  {        //    type: ...,        //    error: {        //      message: 'This is some error'        //    }        //  }      }    }  }});// ❌ DEPRECATEDconst childMachine = createMachine({  entry: escalate('This is some error')});/* ... */
Actors​
Use actor logic creators for invoke.src instead of functions​
Breaking change
The available actor logic creators are:

createMachine
fromPromise
fromObservable
fromEventObservable
fromTransition
fromCallback

See Actors for more information.
XState v5XState v4// ✅import { fromPromise, setup } from 'xstate';const machine = setup({  actors: {    getUser: fromPromise(async ({ input }: { input: { userId: string } }) => {      const data = await getData(input.userId);      // ...      return data;    })  }}).createMachine({  invoke: {    src: 'getUser',    input: ({ context, event }) => ({      userId: context.userId,    }),  },});// ❌ DEPRECATEDimport { createMachine } from 'xstate';const machine = createMachine({  invoke: {    src: (context) => async () => {      const data = await getData(context.userId);      // ...      return data;    },  },});
XState v5XState v4// ✅import { fromCallback, createMachine } from 'xstate';const machine = createMachine({  invoke: {    src: fromCallback(({ sendBack, receive, input }) => {      // ...    }),    input: ({ context, event }) => ({      userId: context.userId,    }),  },});// ❌ DEPRECATEDimport { createMachine } from 'xstate';const machine = createMachine({  invoke: {    src: (context, event) => (sendBack, receive) => {      // context.userId      // ...    },  },});
XState v5XState v4// ✅import { fromEventObservable, createMachine } from 'xstate';import { interval, mapTo } from 'rxjs';const machine = createMachine({  invoke: {    src: fromEventObservable(() =>      interval(1000).pipe(mapTo({ type: 'tick' })),    ),  },});// ❌ DEPRECATEDimport { createMachine } from 'xstate';import { interval, mapTo } from 'rxjs';const machine = createMachine({  invoke: {    src: () => interval(1000).pipe(mapTo({ type: 'tick' })),  },});
Use invoke.input instead of invoke.data​
Breaking change
The invoke.data property is removed. If you want to provide context to invoked actors, use invoke.input:
XState v5XState v4// ✅const someActor = createMachine({  // The input must be consumed by the invoked actor:  context: ({ input }) => input,  // ...});const machine = createMachine({  // ...  invoke: {    src: 'someActor',    input: {      value: 42,    },  },});// ❌ DEPRECATEDconst someActor = createMachine({  // ...});const machine = createMachine({  // ...  invoke: {    src: 'someActor',    data: {      value: 42,    },  },});
Use output in final states instead of data​
Breaking change
To produce output data from a machine which reached its final state, use the top-level output property instead of data:
XState v5XState v4// ✅const machine = createMachine({  // ...  states: {    finished: {      type: 'final',    },  },  output: {    answer: 42,  },});// ❌ DEPRECATEDconst machine = createMachine({  // ...  states: {    finished: {      type: 'final',      data: {        answer: 42,      },    },  },});
To provide a dynamically generated output, replace invoke.data with invoke.output and add a top-level output property:
XState v5XState v4// ✅const machine = createMachine({  // ...  states: {    finished: {      type: 'final',      output: ({ event }) => ({        answer: event.someValue,      }),    },  },  output: ({ event }) => event.output,});// ❌ DEPRECATEDconst machine = createMachine({  // ...  states: {    finished: {      type: 'final',      data: (context, event) => {        answer: event.someValue,      },    },  },});
Don't use property mappers in input or output​
Breaking change
If you want to provide dynamic context to invoked actors, or produce dynamic output from final states, use a function instead of an object with property mappers.
XState v5XState v4// ✅const machine = createMachine({  // ...  invoke: {    src: 'someActor',    input: ({ context, event }) => ({      value: event.value,    }),  },});// The input must be consumed by the invoked actor:const someActor = createMachine({  // ...  context: ({ input }) => input,});// Producing machine outputconst machine = createMachine({  // ...  states: {    finished: {      type: 'final',    },  },  output: ({ context, event }) => ({    answer: context.value,  }),});// ❌ DEPRECATEDconst machine = createMachine({  // ...  invoke: {    src: 'someActor',    data: {      value: (context, event) => event.value, // a property mapper    },  },});// Producing machine outputconst machine = createMachine({  // ...  states: {    finished: {      type: 'final',      data: {        answer: (context, event) => context.value, // a property mapper      },    },  },});
Use actors property on options object instead of services​
Breaking change
services have been renamed to actors:
XState v5XState v4// ✅const specificMachine = machine.provide({  actions: {    /* ... */  },  guards: {    /* ... */  },  actors: {    /* ... */  },  // ...});// ❌ DEPRECATEDconst specificMachine = machine.withConfig({  actions: {    /* ... */  },  guards: {    /* ... */  },  services: {    /* ... */  },  // ...});
Use subscribe() for changes, not onTransition()​
Breaking change
The actor.onTransition(...) method is removed. Use actor.subscribe(...) instead.
XState v5XState v4// ✅const actor = createActor(machine);actor.subscribe((state) => {  // ...});// ❌ DEPRECATEDconst actor = interpret(machine);actor.onTransition((state) => {  // ...});
createActor() (formerly interpret()) accepts a second argument to restore state​
Breaking change
interpret(machine).start(state) is now createActor(machine, { snapshot }).start()
To restore an actor at a specific state, you should now pass the state as the snapshot property of the options argument of createActor(logic, options). The actor.start() property no longer takes in a state argument.
XState v5XState v4// ✅const actor = createActor(machine, { snapshot: someState });actor.start();// ❌ DEPRECATEDconst actor = interpret(machine);actor.start(someState);
Use actor.getSnapshot() to get actor’s state​
Breaking change
Subscribing to an actor (actor.subscribe(...)) after the actor has started will no longer emit the current snapshot immediately. Instead, read the current snapshot from actor.getSnapshot():
XState v5XState v4// ✅const actor = createActor(machine);actor.start();const initialState = actor.getSnapshot();actor.subscribe((state) => {  // Snapshots from when the subscription was created  // Will not emit the current snapshot until a transition happens});// ❌ DEPRECATEDconst actor = interpret(machine);actor.start();actor.subscribe((state) => {  // Current snapshot immediately emitted});
Loop over events instead of using actor.batch()​
Breaking change
The actor.batch([...]) method for batching events is removed.
XState v5XState v4// ✅for (const event of events) {  actor.send(event);}// ❌ DEPRECATEDactor.batch(events);
Pre-migration tip: Update v4 projects to loop over events to send them as a batch.
Use snapshot.status === 'done' instead of snapshot.done​
Breaking change
The snapshot.done property, which was previously in the snapshot object of state machine actors, is removed. Use snapshot.status === 'done' instead, which is available to all actors:
XState v5XState v4// ✅const actor = createActor(machine);actor.start();actor.subscribe((snapshot) => {  if (snapshot.status === 'done') {    // ...  }});// ❌ DEPRECATEDconst actor = interpret(machine);actor.start();actor.subscribe((state) => {  if (state.done) {    // ...  }});
state.nextEvents has been removed​
Breaking change
The state.nextEvents property is removed, since it is not a completely safe/reliable way of determining the next events that can be sent to the actor. If you want to get the next events according to the previous behavior, you can use this helper function:
import type { AnyMachineSnapshot } from 'xstate';function getNextEvents(snapshot: AnyMachineSnapshot) {  return [...new Set([...snapshot._nodes.flatMap((sn) => sn.ownEvents)])];}// Instead of `state.nextEvents`:const nextEvents = getNextEvents(state);
TypeScript​
Use types instead of schema​
Breaking change
The machineConfig.schema property is renamed to machineConfig.types:
XState v5XState v4// ✅const machine = createMachine({  types: {} as {    context: {      /* ...*/    };    events: {      /* ...*/    };  },});// ❌ DEPRECATEDconst machine = createMachine({  schema: {} as {    context: {      /* ...*/    };    events: {      /* ...*/    };  },});
Use types.typegen instead of tsTypes​
Breaking change
XState Typegen does not fully support XState v5 yet. However, strongly-typed machines can still be achieved without Typegen.
The machineConfig.tsTypes property has been renamed and is now at machineConfig.types.typegen.
XState v5XState v4// ✅const machine = createMachine({  types: {} as {    typegen: {};    context: {      /* ...*/    };    events: {      /* ...*/    };  },});// ❌ DEPRECATEDconst machine = createMachine({  tsTypes: {};  schema: {} as {    context: {      /* ...*/    };    events: {      /* ...*/    };  },});
@xstate/react​
useInterpret() is now useActorRef()​
Breaking change
The useInterpret() hook, which is used to return an actorRef ("service" in XState v4), is renamed to useActorRef().
XState v5XState v4// ✅import { useActorRef } from '@xstate/react';const actorRef = useActorRef(machine); // or any other logic// ❌ DEPRECATEDimport { useInterpret } from '@xstate/react';const service = useInterpret(machine);
useActor(logic) now accepts actor logic, not an actor​
Breaking change
The useActor(logic) hook now accepts actor logic (such as fromPromise(...), createMachine(...), etc.) instead of an existing ActorRef.
To use an existing ActorRef, use actor.send(...) to send events and useSelector(actor, ...) to get the snapshot:
XState v5XState v4// ✅import { useSelector } from '@xstate/react';function Component({ someActorRef }) {  const state = useSelector(someActorRef, (s) => s);  return (    <button onClick={() => someActorRef.send({ type: 'someEvent' })} />  );}// ❌ DEPRECATEDimport { useActor } from '@xstate/react';function Component({ someActorRef }) {  const [state, send] = useActor(someActorRef);  return (    <button onClick={() => send({ type: 'someEvent' })} />  );}
Use machine.provide() to provide implementations in hooks​
Breaking change
For dynamically creating machines with provided implementations, the useMachine(...), useActor(...), and useActorRef(...) hooks no longer accept:

Lazy machine creators as the 1st argument
Implementations passed to the 2nd argument

Instead, machine.provide(...) should be passed directly to the 1st argument.
The @xstate/react package considers machines with the same configuration to be the same machine, so it will minimize rerenders but still keep the provided implementations up-to-date.
XState v5XState v4XState v4// ✅import { useMachine } from '@xstate/react';import { someMachine } from './someMachine';function Component(props) {  const [state, send] = useMachine(someMachine.provide({    actions: {      doSomething: () => {        props.onSomething?.(); // Kept up-to-date      }    }  }));  // ...}// ❌ DEPRECATEDimport { useMachine } from '@xstate/react';import { someMachine } from './someMachine';function Component(props) {  const [state, send] = useMachine(someMachine, {    actions: {      doSomething: () => {        props.onSomething?.();      }    }  });  // ...}// ❌ DEPRECATEDimport { useMachine } from '@xstate/react';import { someMachine } from './someMachine';function Component(props) {  const [state, send] = useMachine(() => someMachine.withConfig({    actions: {      doSomething: () => {        props.onSomething?.();      }    }  }));  // ...}
@xstate/vue​
useMachine() now returns snapshot instead of state, and actor instead of service​
Breaking change
To keep consistent naming with the rest of XState and related libraries:

state is now snapshot
service is now actor

XState v5XState v4// ✅import { useMachine } from '@xstate/vue';// ...const {  snapshot, // Renamed from `state`  send,  actor // Renamed from `service`} = useMachine(someMachine)// ❌ DEPRECATEDimport { useMachine } from '@xstate/vue';// ...const {  state, // Renamed to `snapshot` in @xstate/vue 3.0.0  send,  service // Renamed to `actor` in @xstate/vue 3.0.0} = useMachine(someMachine)
New features​

Create actor systems
New actor logic creators
Deep persistence for invoked and spawned actors
Provide input data to state machines and actors
Specify output “done data” for actors
Partial event descriptors (partial wildcards)
Enqueue actions
Higher-level guards
Setup API for specifying types and strongly-typed state values
Inspect API

Frequently asked questions​
When will Stately Studio be compatible with XState v5?​
We are currently working on Stately Studio compatibility with XState v5. Exporting to XState v5 (JavaScript or TypeScript) is already available. We are working on support for new XState v5 features, such as higher-order guards, partial event wildcards, and machine input/output.
Upvote or comment on Stately Studio + XState v5 compatibility in our roadmap to stay updated on our progress.
When will the XState VS Code extension be compatible with XState v5?​
The XState VS Code extension is not yet compatible with XState v5. The extension is a priority for us, and work is already underway.
Upvote or comment on XState v5 compatibility for VS Code extension in our roadmap to stay updated on our progress.
When will XState v5 have typegen?​
TypeScript inference has been greatly improved in XState v5. Especially with features like the setup() API and dynamic parameters, the main use-cases for typegen are no longer needed.
However, we recognize that there may still be some specific use-cases for typegen. Upvote or comment on Typegen for XState v5 in our roadmap to stay updated on our progress.
How can I use both XState v4 and v5?​
You can use both XState v4 and v5 in the same project, which is useful for incrementally migrating to XState v5. To use both, add "xstate5": "npm:xstate@5" to your package.json manually or through the CLI:
npm i xstate5@npm:xstate@5
Then, you can import the v5 version of XState in your code:
import { createMachine } from 'xstate5';// or { createMachine as createMachine5 } from 'xstate5';
If you need to use different versions of an integration package, such as @xstate/react, you can use a similar strategy as above, but you will need to link to the correct version of XState in the integration package. This can be done by using a script:
npm i xstate5@npm:xstate@5 @xstate5/react@npm:@xstate/react@4 --force
// scripts/xstate5-react-script.jsconst fs = require('fs-extra');const path = require('path');const rootNodeModules = path.join(__dirname, '..', 'node_modules');fs.ensureSymlinkSync(  path.join(rootNodeModules, 'xstate5'),  path.join(rootNodeModules, '@xstate5', 'react', 'node_modules', 'xstate'),);
// package.json"scripts": {  "postinstall": "node scripts/xstate5-react-script.js"}
Then, you can use the XState v5 compatible version of @xstate/react in your code:
import { useMachine } from '@xstate5/react';// or { useMachine as useMachine5 } from '@xstate5/react';import { createMachine } from 'xstate5';// or { createMachine as createMachine5 } from 'xstate5';// ...

XState examplesXState v5 examples are also available in the /examples directory. Many of the examples have a CodeSandbox link where you can run the example in your browser.
Simple fetch example​
A simple fetch example built with:


XState v5


Parcel


Simple fetch example on GitHub


Simple fetch example on CodeSandbox


7GUIs counter (React)​
An implementation of the 7GUIs counter built with:


XState v5


React


TypeScript


Vite


7GUIs counter (React) on GitHub


7GUIs counter (React) on CodeSandbox


7GUIs temperature (React)​
This is an implementation of the 7GUIs temperature converter built with:


XState v5


React


TypeScript


Vite


7GUIs temperature (React) on GitHub


7GUIs temperature (React) on CodeSandbox


Simple list (React)​
A React list built with:


XState v5


React


TypeScript


Vite


Simple list (React) on GitHub


Simple list (React) on CodeSandbox


Stopwatch​
A simple stopwatch built with:


XState v5


TypeScript


Vite


Stopwatch on GitHub


Stopwatch on CodeSandbox


Tic-tac-toe game (React)​
An implementation of tic-tac-toe built with:


XState v5


React


TypeScript


Vite


Tic-tac-toe game (React) on GitHub


Tic-tac-toe game (React) on CodeSandbox


Tiles game (React)​
A simple tiles game built with:


XState v5


React


TypeScript


Vite


Tiles game (React) on GitHub


Tiles game (React) on CodeSandbox


TodoMVC (React)​
An implementation of TodoMVC built with:


XState v5


React


TypeScript


Vite


TodoMVC (React) on GitHub


TodoMVC (React) on CodeSandbox


Toggle​
A simple toggle built with:


XState v5


TypeScript


Vite


Toggle on GitHub


Toggle on CodeSandbox


Hello world workflow​
Serverless hello world workflow from the CNCF Serverless Workflow examples built with:

XState v5

Hello world workflow on GitHub
Greeting workflow​
Serverless greeting workflow from the CNCF Serverless Workflow examples built with:

XState v5

Greeting workflow on GitHub
Event-based greeting workflow​
Serverless event-based greeting workflow from the CNCF Serverless Workflow examples built with:

XState v5

Event-based greeting workflow on GitHub
Solving math problems​
Serverless math solving problem workflow from the CNCF Serverless Workflow examples built with:

XState v5

Solving math problems on GitHub
Parallel execution workflow​
Serverless parallel execution workflow from the CNCF Serverless Workflow examples built with:

XState v5

Parallel execution workflow on GitHub
Async function invocation workflow​
Serverless async function invocation workflow from the CNCF Serverless Workflow examples built with:

XState v5

Async function invocation workflow on GitHub
Async subflow invocation workflow​
Serverless async subflow invocation workflow from the CNCF Serverless Workflow examples built with:

XState v5

Async subflow invocation workflow on GitHub
Event-based transitions (event-based switch) workflow​
Serverless event-based transitions workflow from the CNCF Serverless Workflow examples built with:

XState v5

Event-based transitions workflow on GitHub
Applicant request decision workflow​
Serverless applicant request decision workflow from the CNCF Serverless Workflow examples built with:

XState v5

Applicant request decision workflow on GitHub
Provision orders (error handling) workflow​
Serverless provision orders (error handling) workflow from the CNCF Serverless Workflow examples built with:

XState v5

Provision orders (error handling) workflow on GitHub
Monitor job for completion (polling) workflow​
Serverless monitor job for completion (polling) workflow from the CNCF Serverless Workflow examples built with:

XState v5

Monitor job for completion (polling) workflow on GitHub
Send CloudEvent on workflow completion​
Serverless send CloudEvent on workflow completion workflow from the CNCF Serverless Workflow examples built with:

XState v5

Send CloudEvent on workflow completion on GitHub
Monitor patient vital signs workflow​
Serverless monitor patient vital signs workflow from the CNCF Serverless Workflow examples built with:

XState v5

Monitor patient vital signs workflow on GitHub
Finalize college application workflow​
Serverless finalize college application workflow from the CNCF Serverless Workflow examples built with:

XState v5

Finalize college application workflow on GitHub
Perform customer credit check workflow​
Serverless perform customer credit check workflow from the CNCF Serverless Workflow examples built with:

XState v5

Perform customer credit check workflow on GitHub
Handle car auction bids (scheduled start) workflow​
Serverless handle car auction bids (scheduled start) workflow from the CNCF Serverless Workflow examples built with:

XState v5

Handle car auction bids (scheduled start) workflow on GitHub
Check inbox periodically (cron-based workflow start)​
Serverless check inbox periodically (cron-based workflow start) from the CNCF Serverless Workflow examples built with:

XState v5

Check inbox periodically (cron-based workflow start) on GitHub
Event-based service workflow​
Serverless event-based service workflow from the CNCF Serverless Workflow examples built with:

XState v5

Event-based service workflow on GitHub
Reusing function and event definitions workflow​
Serverless reusing function and event definitions workflow from the CNCF Serverless Workflow examples built with:

XState v5

Reusing function and event definitions workflow on GitHub
New patient onboarding (error checking and retries) workflow​
Serverless new patient onboarding (error checking and retries) workflow from the CNCF Serverless Workflow examples.
New patient onboarding (error checking and retries) workflow on GitHub
Purchase order deadline (ExecTimeout) workflow​
Serverless purchase order deadline (ExecTimeout) workflow from the CNCF Serverless Workflow examples built with:

XState v5

Purchase order deadline (ExecTimeout) workflow on GitHub
Accumulate room readings and create timely reports (ExecTimeout and KeepActive) workflow​
Serverless accumulate room readings and create timely reports (ExecTimeout and KeepActive) workflow from the CNCF Serverless Workflow examples built with:

XState v5

Accumulate room readings and create timely reports (ExecTimeout and KeepActive) workflow on GitHub
Car vitals checks (SubFlow Repeat) workflow​
Store a single bid when the car auction is active.
Serverless car vitals checks (SubFlow Repeat) workflow from the CNCF Serverless Workflow examples built with:

XState v5

Car vitals checks (SubFlow Repeat) workflow on GitHub
Book lending workflow​
Serverless book lending workflow from the CNCF Serverless Workflow examples built with:

XState v5

Book lending workflow on GitHub
Filling a glass of water workflow​
Serverless filling a glass of water workflow from the CNCF Serverless Workflow examples built with:

XState v5

Filling a glass of water workflow on GitHub
More examples coming soon​
If you have any examples you want us to make, please add a request to our feedback board or upvote an existing suggestion.
If you have an example you want to share, contribute your example to the XState repository.

TemplatesXState runs anywhere you can run JavaScript and is framework-agnostic.
You can get started with or without your framework of choice using the templates below.
TemplateUses🤖 XState Template 
Open in CodeSandbox 
Open in StackBlitz
XState v5
TypeScript
No framework
⚛️ XState + React Template 
Open in CodeSandbox 
Open in StackBlitz
React
XState v5
TypeScript
💚 XState + Vue Template 
Open in CodeSandbox 
Open in StackBlitz
Vue
XState v5
TypeScript


CheatsheetUse this cheatsheet to quickly look up the syntax for XState v5.
Installing XState​
npmpnpmyarnnpm install xstatepnpm install xstateyarn add xstate
Read more on installing XState.
Creating a state machine​
import { setup, createActor, assign } from 'xstate';const machine = setup({/* ... */})  .createMachine({    id: 'toggle',    initial: 'active',    context: { count: 0 },    states: {      active: {        entry: assign({          count: ({ context }) => context.count + 1,        }),        on: {          toggle: { target: 'inactive' },        },      },      inactive: {        on: {          toggle: { target: 'active' },        },      },    },  });const actor = createActor(machine);actor.subscribe((snapshot) => {  console.log(snapshot.value);});actor.start();// logs 'active' with context { count: 1 }actor.send({ type: 'toggle' });// logs 'inactive' with context { count: 1 }actor.send({ type: 'toggle' });// logs 'active' with context { count: 2 }actor.send({ type: 'toggle' });// logs 'inactive' with context { count: 2 }
Read more about the actor model.
Creating promise logic​
import { fromPromise, createActor } from 'xstate';const promiseLogic = fromPromise(async () => {  const response = await fetch('https://dog.ceo/api/breeds/image/random');  const dog = await response.json();  return dog;});const actor = createActor(promiseLogic);actor.subscribe((snapshot) => {  console.log(snapshot);});actor.start();// logs: {//   message: "https://images.dog.ceo/breeds/kuvasz/n02104029_110.jpg",//   status: "success"// }
Read more about promise actor logic.
Creating transition logic​
A transition function is just like a reducer.
import { fromTransition, createActor } from 'xstate';const transitionLogic = fromTransition(  (state, event) => {    switch (event.type) {      case 'inc':        return {          ...state,          count: state.count + 1,        };      default:        return state;    }  },  { count: 0 }, // initial state);const actor = createActor(transitionLogic);actor.subscribe((snapshot) => {  console.log(snapshot);});actor.start();// logs { count: 0 }actor.send({ type: 'inc' });// logs { count: 1 }actor.send({ type: 'inc' });// logs { count: 2 }
Read more about transition actors.
Creating observable logic​
import { fromObservable, createActor } from 'xstate';import { interval } from 'rxjs';const observableLogic = fromObservable(() => interval(1000));const actor = createActor(observableLogic);actor.subscribe((snapshot) => {  console.log(snapshot);});actor.start();// logs 0, 1, 2, 3, 4, 5, ...// every second
Read more about observable actors.
Creating callback logic​
import { fromCallback, createActor } from 'xstate';const callbackLogic = fromCallback(({ sendBack, receive }) => {  const i = setTimeout(() => {    sendBack({ type: 'timeout' });  }, 1000);  receive((event) => {    if (event.type === 'cancel') {      console.log('canceled');      clearTimeout(i);    }  });  return () => {    clearTimeout(i);  };});const actor = createActor(callbackLogic);actor.start();actor.send({ type: 'cancel' });// logs 'canceled'
Read more about callback actors.
Parent states​
import { setup, createActor } from 'xstate';const machine = setup({/* ... */})  .createMachine({    id: 'parent',    initial: 'active',    states: {      active: {        initial: 'one',        states: {          one: {            on: {              NEXT: { target: 'two' }            }          },          two: {},        },        on: {          NEXT: { target: 'inactive' }        }      },      inactive: {},    },  });const actor = createActor(machine);actor.subscribe((snapshot) => {  console.log(snapshot.value);});actor.start();// logs { active: 'one' }actor.send({ type: 'NEXT' });// logs { active: 'two' }actor.send({ type: 'NEXT' });// logs 'inactive'
Read more about parent states.
Actions​
import { setup, createActor } from 'xstate';const machine = setup({  actions: {    activate: () => {/* ... */},    deactivate: () => {/* ... */},    notify: (_, params: { message: string }) => {/* ... */},  }}).createMachine({  id: 'toggle',  initial: 'active',  states: {    active: {      entry: { type: 'activate' },      exit: { type: 'deactivate' },      on: {        toggle: {          target: 'inactive',          actions: [{ type: 'notify' }],        },      },    },    inactive: {      on: {        toggle: {          target: 'active',          actions: [            // action with params            {              type: 'notify',              params: {                message: 'Some notification',              },            },          ],        },      },    },  },});const actor = createActor(  machine.provide({    actions: {      notify: (_, params) => {        console.log(params.message ?? 'Default message');      },      activate: () => {        console.log('Activating');      },      deactivate: () => {        console.log('Deactivating');      },    },  }),);actor.start();// logs 'Activating'actor.send({ type: 'toggle' });// logs 'Deactivating'// logs 'Default message'actor.send({ type: 'toggle' });// logs 'Some notification'// logs 'Activating'
Read more about actions.
Guards​
import { setup, createActor } from 'xstate';const machine = setup({  guards: {    canBeToggled: ({ context }) => context.canActivate,    isAfterTime: (_, params) => {      const { time } = params;      const [hour, minute] = time.split(':');      const now = new Date();      return now.getHours() > hour && now.getMinutes() > minute;    },  },  actions: {    notifyNotAllowed: () => {      console.log('Cannot be toggled');    },  },}).createMachine({  id: 'toggle',  initial: 'active',  context: {    canActivate: false,  },  states: {    inactive: {      on: {        toggle: [          {            target: 'active',            guard: 'canBeToggled',          },          {            actions: 'notifyNotAllowed',          },        ],      },    },    active: {      on: {        toggle: {          // Guard with params          guard: { type: 'isAfterTime', params: { time: '16:00' } },          target: 'inactive',        },      },      // ...    },  },});const actor = createActor(machine);actor.start();// logs 'Cannot be toggled'
Read more about guards.
Invoking actors​
import { setup, fromPromise, createActor, assign } from 'xstate';const loadUserLogic = fromPromise(async () => {  const response = await fetch('https://jsonplaceholder.typicode.com/users/1');  const user = await response.json();  return user;});const machine = setup({  actors: { loadUserLogic }}).createMachine({  id: 'toggle',  initial: 'loading',  context: {    user: undefined,  },  states: {    loading: {      invoke: {        id: 'loadUser',        src: 'loadUserLogic',        onDone: {          target: 'doSomethingWithUser',          actions: assign({            user: ({ event }) => event.output,          }),        },        onError: {          target: 'failure',          actions: ({ event }) => {            console.log(event.error)          }        }      },    },    doSomethingWithUser: {      // ...    },    failure: {      // ...    },  },});const actor = createActor(machine);actor.subscribe((snapshot) => {  console.log(snapshot.context.user);});actor.start();// eventually logs:// { id: 1, name: 'Leanne Graham', ... }
Read more about invoking actors.
Spawning actors​
import { setup, fromPromise, createActor, assign } from 'xstate';const loadUserLogic = fromPromise(async () => {  const response = await fetch('https://jsonplaceholder.typicode.com/users/1');  const user = await response.json();  return user;});const machine = setup({  actors: {    loadUserLogic  }}).createMachine({  context: {    userRef: undefined,  },  on: {    loadUser: {      actions: assign({        userRef: ({ spawn }) => spawn('loadUserLogic'),      }),    },  },});const actor = createActor(machine);actor.subscribe((snapshot) => {  const { userRef } = snapshot.context;  console.log(userRef?.getSnapshot());});actor.start();actor.send({ type: 'loadUser' });// eventually logs:// { id: 1, name: 'Leanne Graham', ... }
Read more about spawning actors.
Input and output​
import { setup, createActor } from 'xstate';const greetMachine = setup({  types: {    context: {} as { message: string },    input: {} as { name: string },  }}).createMachine({  context: ({ input }) => ({    message: `Hello, ${input.name}`,  }),  entry: ({ context }) => {    console.log(context.message);  },});const actor = createActor(greetMachine, {  input: {    name: 'David',  },});actor.start();// logs 'Hello, David'
Read more about input.
Invoking actors with input​
import { setup, createActor, fromPromise } from 'xstate';const loadUserLogic = fromPromise(async ({ input }) => {  const response = await fetch(    `https://jsonplaceholder.typicode.com/users/${input.id}`,  );  const user = await response.json();  return user;});const machine = setup({  actors: {    loadUserLogic  }}).createMachine({  initial: 'loading user',  states: {    'loading user': {      invoke: {        id: 'loadUser',        src: 'loadUserLogic',        input: {          id: 3,        },        onDone: {          actions: ({ event }) => {            console.log(event.output);          },        },      },    },  },});const actor = createActor(machine);actor.start();// eventually logs:// { id: 3, name: 'Clementine Bauch', ... }
Read more about invoking actors with input.
Types​
import { setup, fromPromise } from 'xstate';const promiseLogic = fromPromise(async () => {  /* ... */});const machine = setup({  types: {    context: {} as {      count: number;    };    events: {} as       | { type: 'inc'; }      | { type: 'dec' }      | { type: 'incBy'; amount: number };    actions: {} as       | { type: 'notify'; params: { message: string } }      | { type: 'handleChange' };    guards: {} as       | { type: 'canBeToggled' }      | { type: 'isAfterTime'; params: { time: string } };    children: {} as {      promise1: 'someSrc';      promise2: 'someSrc';    };    delays: 'shortTimeout' | 'longTimeout';    tags: 'tag1' | 'tag2';    input: number;    output: string;  },  actors: {    promiseLogic  }}).createMachine({  // ...});

TypeScriptXState v5 and its related libraries are written in TypeScript, and utilize complex types to provide the best type safety and inference possible for you.
XState v5 requires TypeScript version 5.0 or greater.For best results, use the latest TypeScript version.
Follow these guidelines to ensure that your TypeScript project is ready to use XState v5:
Use the latest version of TypeScript​
Use the latest version of TypeScript; version 5.0 or greater is required.
   npm install typescript@latest --save-dev
Set up your tsconfig.json file​

Set strictNullChecks to true in your tsconfig.json file. This will ensure that our types work correctly and help catch errors in your code. (Strongly recommended).
Set skipLibCheck to true in your tsconfig.json file. (Recommended).

// tsconfig.json{  "compilerOptions": {    // ...    "strictNullChecks": true,    // or set `strict` to true, which includes `strictNullChecks`    // "strict": true,    "skipLibCheck": true,  }}
Specifying types​
The recommended way to strongly type your machine is to use the setup(...) function:
import { setup } from 'xstate';const feedbackMachine = setup({  types: {    context: {} as { feedback: string },    events: {} as      | { type: 'feedback.good' }      | { type: 'feedback.bad' }  },  actions: {    logTelemetry: () => {      // TODO: implement    }  }}).createMachine({  // ...});
You can also specify TypeScript types inside the machine config using the .types property:
import { createMachine } from 'xstate';const feedbackMachine = createMachine({  types: {} as {    context: { feedback: string };    events: { type: 'feedback.good' } | { type: 'feedback.bad' };    actions: { type: 'logTelemetry' };  },});
These types will be inferred throughout the machine config and in the created machine and actor so that methods such as machine.transition(...) and actor.send(...) will be type-safe.
Dynamic parameters​
It is recommended to use dynamic parameters in actions and guards as they allow you to make reusable functions that are not closely tied to the machine, and are strongly-typed.
import { setup } from 'xstate';const feedbackMachine = setup({  types: {    context: {} as {      user: { name: string };    }  },  actions: {    greet: (_, params: { name: string }) => {      console.log(`Hello, ${params.name}!`);    }  }}).createMachine({  context: {    user: {      name: 'David'    }  },  // ...  entry: {    type: 'greet',    params: ({ context }) => ({      name: context.user.name    })  }});
Asserting events​
It is strongly recommended to use dynamic parameters instead of directly accessing the event object whenever possible for improved type safety and reusability.
If using dynamic parameters is infeasible and you must use the event in an action or guard implementation, you can assert the event type using the assertEvent(...) helper function:
import { createMachine, assertEvent } from 'xstate';const machine = createMachine({  types: {    events: {} as      | { type: 'greet'; message: string }      | { type: 'log'; message: string }      | { type: 'doSomethingElse' }  },  // ...  states: {    someState: {      entry: ({ event }) => {        // In the entry action, it is currently not possible to know        // which event this action was called with.        // Calling `assertEvent` will throw if        // the event is not the expected type.        assertEvent(event, 'greet');        // Now we know the event is a `greet` event,        // and we can access its `message` property.        console.log(event.message.toUpperCase());      },      // ...      exit: ({ event }) => {        // You can also assert multiple possible event types.        assertEvent(event, ['greet', 'log']);        // Now we know the event is a `greet` or `log` event,        // and we can access its `message` property.        console.log(event.message.toUpperCase());      }    }  }})
Type helpers​
XState provides some type helpers to make it easier to work with types in TypeScript.
ActorRefFrom<T>​
Results in an ActorRef from the provided T actor logic parameter, which is useful for creating strongly-typed actors. The T parameter can be any ActorLogic, such as the return value of createMachine(…), or any other actor logic, such as fromPromise(…) or fromObservable(…).
import { type ActorRefFrom } from 'xstate';import { someMachine } from './someMachine';type SomeActorRef = ActorRefFrom<typeof someMachine>;
SnapshotFrom<T>​
Results in a Snapshot from the provided T parameter, which is useful for creating strongly-typed snapshots. The T parameter can be any ActorLogic or ActorRef.
import { type SnapshotFrom } from 'xstate';import { someMachine } from './someMachine';type SomeSnapshot = SnapshotFrom<typeof someMachine>;
EventFromLogic<T>​
Results in an union of all event types defined in the provided T actor logic parameter. Useful for type-safe event handling.
import { type EventFromLogic } from 'xstate';import { someMachine } from './someMachine';// SomeEvent would be a union of all event// types defined in `someMachine`.type SomeEvent = EventFromLogic<typeof someMachine>;
Typegen​
Typegen does not yet support XState v5. However, with the setup(...) function and/or the .types property explained above, you can provide strong typing for most (if not all) of your machine.
If you were previously using typegen to narrow down events used in actions or guards, you can use the assertEvent(...) helper function to narrow down the event type.



What are state machines and statecharts?State machines help us model how a process goes from state to state when an event occurs.
State machines are useful in software development because they help us capture all the states, events and transitions between them. Using state machines makes it easier to find impossible states and spot undesirable transitions.
State machines model your application logic. Below is the logic for a video player. When the video is Played, it is opened into fullscreen mode. When the video is stopped, it closes out of fullscreen mode. When the video player is in fullscreen mode, it can be Playing or Paused.
View the Video player machine in Stately Studio.
Benefits of state machines​

Simple to understand. State machines are visual and simple to understand. They’re a great way to communicate with your team and stakeholders.
Simple to test. State machines are deterministic, which means they’re simple to test. You can test all the possible states and transitions between them.
Simple to implement. State machines are simple to implement in any programming language. You can use a library or write your own.
Simple to maintain. State machines are simple to maintain because they’re simple to understand, test and implement.
They provide a clear and concise way to model complex user interfaces and manage application state.
State machines can help reduce complexity and improve maintainability by providing a structured way to manage state transitions and handle events.
They can also help prevent bugs and improve code quality by enforcing a clear separation of concerns between different parts of the application.
Additionally, state machines can be highly maintainable and offer a way to make very complex front-end processes much more manageable.

In the backend​

State machines simplify the design and implementation of complex workflows, which can help reduce complexity and improve maintainability. https://developers.redhat.com/articles/2021/11/23/how-design-state-machines-microservices

What is a statechart?​
Statecharts extend traditional finite state machines to model more complex logic.
Statecharts are a visual extension to state machines that use boxes and arrows, much like flowcharts and sequence diagrams. Statecharts add extra features not available in ordinary state machines, including hierarchy, concurrency and communication.
When you make a state machine in Stately Studio, it’s also a statechart!
In Stately Studio, we refer to both state machines and statecharts as state machines.
States​
A state describes the machine’s status or mode, which could be as simple as Asleep and Awake. A state machine can only be in one state at a time.


View the dog states machine in Stately Studio.
A dog is always asleep or awake. The dog can’t be asleep and awake at the same time, and it’s impossible for the dog to be neither asleep nor awake. There are only these two states, a precisely limited, finite number of states.
When a state machine starts, it enters the initial state first. A machine can only have one top-level initial state; if there were multiple initial states, the machine wouldn’t know where to start!
In this statechart describing the process of walking the dog, the initial state would be waiting to walk.

Read more about states.
Read more about finite states.
Read more about initial states.

States in XState​
States are defined in XState state machines inside the states property.
import { createMachine } from 'xstate';const dogMachine = createMachine({  id: 'dog',  initial: 'asleep',  states: {    asleep: {      // ...    },    awake: {      // ...    },    //...  }});
States in Stately Studio​The rounded rectangle boxes are states. Read how to create states in Stately Studio.
Transitions and events​
How the dog goes between asleep and awake is through transitions. Events cause transitions; when an event happens, the machine transitions to the next state. The dog goes between asleep and awake through the wake up and fall asleep events.
Transitions are “deterministic”; each combination of state and event always points to the same next state. Dogs never wake up to become asleep or fall asleep to become awake.


View the dog states machine with events and transitions in Stately Studio.
With its two finite states and transitions, this tiny dog process is a Finite State Machine. A state machine is used to describe the behavior of something. The machine describes the thing’s states and the transitions between those states. It’s a Finite State Machine because it has a finite number of states. (Sometimes abbreviated to FSM by folks who love jargon).
Read more about transitions and events.
Events and transitions in XState​
Events and transitions are defined in XState state machines inside the on property of a state.
import { createMachine } from 'xstate';const dogMachine = createMachine({  id: 'dog',  initial: 'asleep',  states: {    asleep: {      on: {        'wakes up': 'awake',      }    },    awake: {      on: {        'falls asleep': 'asleep',      }    },    //...  }});
Events and transitions in Stately Studio​In Stately Studio, the arrows are transitions, and the rounded rectangles on the arrow’s lines are events. Each transition has a source state which comes before the transition, and a target state, which comes after the transition. The transition’s arrow starts from the source state and points to the target state. Read how to create events and transitions in Stately Studio.
Final state​
Most processes with states will have a final state, the last state when the process is finished. The final state is represented by a double border on the state’s rounded rectangle box.
In the dog walking statechart, the final state would be walk complete.

View the dog walk machine in Stately Studio.
Read more about final states
Parent states​
A parent state is a state that can contain more states, also known as child states. These child states can only happen when the parent state is happening. Inside the on a walk state, there could be the child states of walking and running.
A parent state is symbolised by a labelled rectangle box that acts as a container for its child states. Parent states are sometimes known as compound states.


View the dog walk machine in Stately Studio.
A parent state should also specify which child state is the initial state. In the on a walk parent state, the initial state is walking.
Parent and child states are one of the features that make statecharts capable of handling more complexity than an daily:run state machine.
Read more about parent states.
Atomic states​
An atomic state is a state that doesn’t have any child states. Waiting, walk complete, walking and running are all atomic states.
Parallel states​
A parallel state is a state where all of its child states, also known as regions, are active simultaneously. The regions are separated inside the parallel state container by a dashed line.
Inside the on a walk parallel state, there could be two regions. One region contains the dog’s activity child states of walking and running, and the other region containing the dog’s tail states of wagging and not wagging. The dog can walk and wag its tail or run and wag its tail, it can also do both of these activities without wagging its tail.


View the dog walk machine in Stately Studio.
Both regions should also specify which child state is the initial state. In our tail region, the initial state is not wagging.
Read more about parallel states.
Self-transition​
A self-transition is when an event happens, but the transition returns to the same state. The transition arrow exits and re-enters the same state.
A helpful way to describe a self-transition is “doing something, not going somewhere” in the process.
In a dog begging process, there would be a begging state with a gets treat event. And for the dogs who love their food, no matter how many times you go through the gets treat event, the dog returns to its begging state.


View the dog begging machine in Stately Studio.
Read more about self transitions
What next?​
Now you know enough to get started in the Stately Studio. Get an overview of Stately Studio and its features, or continue to learn about XState.

The Actor modelThe Actor model in computer science is a mathematical model of concurrent computation in which an “actor” is the basic building block.
The actor model allows developers to build reliable message-based systems by using actors to communicate. State machines and statecharts can model the logic of actors. These actors can communicate with each other, and with other actors, in the same way.
When you run a state machine in XState, it becomes an actor.
What defines an “actor”?​
Actors are independent “live” objects that can communicate with each other via asynchronous message passing. In XState, we refer to these messages as events.

An actor has its own internal, encapsulated state that can only be updated by the actor itself. An actor may choose to update its internal state in response to a message it receives, but it cannot be updated by any other entity.
Actors communicate with other actors by sending and receiving events asynchronously.
Actors process one message at a time. They have an internal “mailbox” that acts like an event queue, processing events sequentially.
Internal actor state is not shared between actors. The only way for an actor to share any part of its internal state is by:

Sending events to other actors
Or emitting snapshots, which can be considered implicit events sent to subscribers.


Actors can create (spawn/invoke) new actors.

You’ll find strong similarities to the actor model in software you may already be familiar with. The concept of objects encapsulating state and passing messages to each other may be familiar from Object-Oriented Programming. And actors are analagous to real-world physical concepts like cell biology, and communication in human relationships.
State​
An actor has its own internal, encapsulated state that only the actor itself can update. An actor may update its internal state in response to a message it receives, but it cannot be updated by any other entity. Actors do not share state. The only way for an actor to share data is by sending events.
Read more about XState actors and state.
Communication with events​
Actors communicate with other actors by sending and receiving events asynchronously. Actors use an internal “mailbox” that acts like an event queue, processing events one at a time.
Read more about XState events and transitions.
Spawning​
Actors can spawn new actors, which is useful in situations where an actor needs to delegate work to another actor. Spawning allows for a flexible and dynamic system where actors can be created and destroyed as needed to handle the workload efficiently.

Read more about spawning actors in XState.
Read about the difference between invoking and spawning actors in XState.

The actor model in backend development​
The actor model is often used to coordinate backend systems. There are direct implementations of the Actor model, like Akka for the JVM. In Erlang, processes can be seen as actors, which can send and receive messages and spawn new processes. Erlang is used by massive distributed systems, like Discord and WhatsApp.
In Stately Sky, a state machine actor can be used to manage long-running backend processes like medical patient onboarding flows, inventory management, or multi-player collaborative experiences like whiteboard canvases or games.
The actor model in frontend development​
The actor model is especially useful for coordinating the many moving parts of a front-end web application.
Your front-end app is always a distributed system, and managing distributed systems is where the actor model shines. This is because in a browser environment you never really have a “global source of truth”, you instead have many independent sources of state and events: 3rd-party components, local component state, local storage, query parameters, routers, network I/O, DOM events and their listeners, etc.

[…] there is no such thing as a single source of truth in any non-trivial application. All applications, even front-end apps, are distributed at some level. – via: Redux is Half of a Pattern (2/2)

So even for simple web apps, with small app-specific state and a few known app-specific events, the actor model can be helpful.
XState​
Actors in XState can:

Accept messages as events passed to their own internal logic, or for state machines as received by transitions.
Create more actors within a state machine using spawn in an assign, or using the spawnChild action creator. For details, see Spawn.
Send more messages as events using self.send in their own logic, or action creators like sendTo or raise in a state machine.

Actors in XState have their own actor logic which they use to:

Make local decisions
Determine how to respond to the next message received
Modify their own private state (but only affect each other via messaging)

Actors in XState exist in systems and can communicate with each other within and across those systems.
Reference​

What is the actor model and when should I use it?
The Actor Model Explained in 5 Minutes
Wikipedia: Actor model


XStateXState is a state management and orchestration solution for JavaScript and TypeScript apps.
It uses event-driven programming, state machines, statecharts, and the actor model to handle complex logic in predictable, robust, and visual ways. XState provides a powerful and flexible way to manage application and workflow state by allowing developers to model logic as actors and state machines. It integrates well with React, Vue, Svelte, and other frameworks and can be used in the frontend, backend, or wherever JavaScript runs.
Want to find out more about state machines? Read our introduction.
Installation​
XState is available on npm:
npmpnpmyarnnpm install xstatepnpm install xstateyarn add xstate
Create a simple machine​
import { createMachine, assign, createActor } from 'xstate';const countMachine = createMachine({  context: {    count: 0,  },  on: {    INC: {      actions: assign({        count: ({ context }) => context.count + 1,      }),    },    DEC: {      actions: assign({        count: ({ context }) => context.count - 1,      }),    },    SET: {      actions: assign({        count: ({ event }) => event.value,      }),    },  },});const countActor = createActor(countMachine).start();countActor.subscribe((state) => {  console.log(state.context.count);});countActor.send({ type: 'INC' });// logs 1countActor.send({ type: 'DEC' });// logs 0countActor.send({ type: 'SET', value: 10 });// logs 10
View the  machine in Stately Studio.
Check out more cheatsheet examples.
Create a more complex machine​
import { createMachine, assign, createActor } from 'xstate';const textMachine = createMachine({  context: {    committedValue: '',    value: '',  },  initial: 'reading',  states: {    reading: {      on: {        'text.edit': { target: 'editing' },      },    },    editing: {      on: {        'text.change': {          actions: assign({            value: ({ event }) => event.value,          }),        },        'text.commit': {          actions: assign({            committedValue: ({ context }) => context.value,          }),          target: 'reading',        },        'text.cancel': {          actions: assign({            value: ({ context }) => context.committedValue,          }),          target: 'reading',        },      },    },  },});const textActor = createActor(textMachine).start();textActor.subscribe((state) => {  console.log(state.context.value);});textActor.send({ type: 'text.edit' });// logs ''textActor.send({ type: 'text.change', value: 'Hello' });// logs 'Hello'textActor.send({ type: 'text.commit' });// logs 'Hello'textActor.send({ type: 'text.edit' });// logs 'Hello'textActor.send({ type: 'text.change', value: 'Hello world' });// logs 'Hello world'textActor.send({ type: 'text.cancel' });// logs 'Hello'
View the  machine in Stately Studio.
Download the XState VS Code extension​
The XState VS Code extension does not fully support XState v5 yet.

Visual Studio Marketplace
Open VSX Registry

Read more about our developer tools.
Packages​

🤖 xstate: Core finite state machine and statecharts library + actors
📉 @xstate/graph: Graph traversal utilities for XState
⚛️ @xstate/react: React hooks and utilities for using XState in React applications
💚 @xstate/vue: Vue composition functions and utilities for using XState in Vue applications
🎷 @xstate/svelte: Svelte utilities for using XState in Svelte applications
✅ @xstate/test: Model-Based-Testing utilities (using XState) for testing any software


ActorsWhen you run a state machine, it becomes an actor: a running process that can receive events, send events and change its behavior based on the events it receives, which can cause effects outside of the actor.
In state machines, actors can be invoked or spawned. These are essentially the same, with the only difference being how the actor’s lifecycle is controlled.

An invoked actor is started when its parent machine enters the state it is invoked in, and stopped when that state is exited.
A spawned actor is started in a transition and stopped either with a stop(...) action or when its parent machine is stopped.

You can visualize your state machines and easily invoke actors in our drag-and-drop Stately editor. Read more about actors in Stately’s editor.
Watch our “XState: exploring actors” deep dive video on YouTube.

Actor model​
In the actor model, actors are objects that can communicate with each other. They are independent “live” entities that communicate via asynchronous message passing. In XState, these messages are referred to as events.

An actor has its own internal, encapsulated state that can only be updated by the actor itself. An actor may choose to update its internal state in response to a message it receives, but it cannot be updated by any other entity.
Actors communicate with other actors by sending and receiving events asynchronously.
Actors process one message at a time. They have an internal “mailbox” that acts like an event queue, processing events sequentially.
Internal actor state is not shared between actors. The only way for an actor to share any part of its internal state is by:

Sending events to other actors
Or emitting snapshots, which can be considered implicit events sent to subscribers.


Actors can create (spawn/invoke) new actors.

Read more about the Actor model
Actor logic​
Actor logic is the actor’s logical “model” (brain, blueprint, DNA, etc.) It describes how the actor should change behavior when receiving an event. You can create actor logic using actor logic creators.
In XState, actor logic is defined by an object implementing the ActorLogic interface, containing methods like .transition(...), .getInitialSnapshot(), .getPersistedSnapshot(), and more. This object tells an interpreter how to update an actor’s internal state when it receives an event and which effects to execute (if any).
Creating actors​
You can create an actor, which is a “live” instance of some actor logic, via createActor(actorLogic, options?). The createActor(...) function takes the following arguments:

actorLogic: the actor logic to create an actor from
options (optional): actor options

When you create an actor from actor logic via createActor(actorLogic), you implicitly create an actor system where the created actor is the root actor. Any actors spawned from this root actor and its descendants are part of that actor system. The actor must be started by calling actor.start(), which will also start the actor system:
import { createActor } from 'xstate';import { someActorLogic } from './someActorLogic.ts';const actor = createActor(someActorLogic);actor.subscribe((snapshot) => {  console.log(snapshot);});actor.start();// Now the actor can receive eventsactor.send({ type: 'someEvent' });
You can stop root actors by calling actor.stop(), which will also stop the actor system and all actors in that system:
// Stops the root actor, actor system, and actors in the systemactor.stop();
Invoking and spawning actors​
An invoked actor represents a state-based actor, so it is stopped when the invoking state is exited. Invoked actors are used for a finite/known number of actors.
A spawned actor represents multiple entities that can be started at any time and stopped at any time. Spawned actors are action-based and used for a dynamic or unknown number of actors.
An example of the difference between invoking and spawning actors could occur in a todo app. When loading todos, a loadTodos actor would be an invoked actor; it represents a single state-based task. In comparison, each of the todos can themselves be spawned actors, and there can be a dynamic number of these actors.

Read more about invoking actors
Read more about spawning actors

Actor snapshots​
When an actor receives an event, its internal state may change. An actor may emit a snapshot when a state transition occurs. You can read an actor’s snapshot synchronously via actor.getSnapshot(), or you can subscribe to snapshots via actor.subscribe(observer).
import { fromPromise, createActor } from 'xstate';async function fetchCount() {  return Promise.resolve(42);}const countLogic = fromPromise(async () => {  const count = await fetchCount();  return count;});const countActor = createActor(countLogic);countActor.start();countActor.getSnapshot(); // logs undefined// After the promise resolves...countActor.getSnapshot();// => {//   output: 42,//   status: 'done',//   ...// }
Subscriptions​
You can subscribe to an actor’s snapshot values via actor.subscribe(observer). The observer will receive the actor’s snapshot value when it is emitted. The observer can be:

A plain function that receives the latest snapshot, or
An observer object whose .next(snapshot) method receives the latest snapshot

// Observer as a plain functionconst subscription = actor.subscribe((snapshot) => {  console.log(snapshot);});
// Observer as an objectconst subscription = actor.subscribe({  next(snapshot) {    console.log(snapshot);  },  error(err) {    // ...  },  complete() {    // ...  },});
The return value of actor.subscribe(observer) is a subscription object that has an .unsubscribe() method. You can call subscription.unsubscribe() to unsubscribe the observer:
const subscription = actor.subscribe((snapshot) => {  /* ... */});// Unsubscribe the observersubscription.unsubscribe();
When the actor is stopped, all of its observers will automatically be unsubscribed.
You can initialize actor logic at a specific persisted snapshot (state) by passing the state in the second options argument of createActor(logic, options). If the state is compatible with the actor logic, this will create an actor that will be started at that persisted state:
const persistedState = JSON.parse(localStorage.getItem('some-persisted-state'));const actor = createActor(someLogic, {  snapshot: persistedState,});actor.subscribe(() => {  localStorage.setItem(    'some-persisted-state',    JSON.stringify(actor.getPersistedSnapshot()),  );});// Actor will start at persisted stateactor.start();
See persistence for more details.
You can wait for an actor’s snapshot to satisfy a predicate using the waitFor(actor, predicate, options?) helper function. The waitFor(...) function returns a promise that is:

Resolved when the emitted snapshot satisfies the predicate function
Resolved immediately if the current snapshot already satisfies the predicate function
Rejected if an error is thrown or the options.timeout value is elapsed.

import { waitFor } from 'xstate';import { countActor } from './countActor.ts';const snapshot = await waitFor(  countActor,  (snapshot) => {    return snapshot.context.count >= 100;  },  {    timeout: 10_000, // 10 seconds (10,000 milliseconds)  },);console.log(snapshot.output);// => 100
Error handling​
You can subscribe to errors thrown by an actor using the error callback in the observer object passed to actor.subscribe(). This allows you to handle errors emitted by the actor logic.
import { createActor } from 'xstate';import { someMachine } from './someMachine';const actor = createActor(someMachine);actor.subscribe({  next: (snapshot) => {    // ...  },  error: (err) => {    // Handle the error here    console.error(err);  }});actor.start();
Actor logic creators​
The types of actor logic you can create from XState are:

State machine logic (createMachine(...))
Promise logic (fromPromise(...))
Transition function logic (fromTransition(...))
Observable logic (fromObservable(...))
Event observable logic (fromEventObservable(...))
Callback logic (fromCallback(...))

Actor logic capabilities​
Receive eventsSend eventsSpawn actorsInputOutputState machine actors✅✅✅✅✅Promise actors❌✅❌✅✅Transition actors✅✅❌✅❌Observable actors❌✅❌✅❌Callback actors✅✅❌✅❌
State machine logic (createMachine(...))​
You can describe actor logic as a state machine. Actors created from state machine actor logic can:

Receive events
Send events to other actors
Invoke/spawn child actors
Emit snapshots of its state
Output a value when the machine reaches its top-level final state

const toggleMachine = createMachine({  id: 'toggle',  initial: 'inactive',  states: {    inactive: {},    active: {},  },});const toggleActor = createActor(toggleMachine);toggleActor.subscribe((snapshot) => {  // snapshot is the machine's state  console.log('state', snapshot.value);  console.log('context', snapshot.context);});toggleActor.start();// Logs 'inactive'toggleActor.send({ type: 'toggle' });// Logs 'active'
Learn more about state machine actors.
Promise logic (fromPromise(...))​
Promise actor logic is described by an async process that resolves or rejects after some time. Actors created from promise logic (“promise actors”) can:

Emit the resolved value of the promise
Output the resolved value of the promise

Sending events to promise actors will have no effect.
const promiseLogic = fromPromise(() => {  return fetch('https://example.com/...').then((data) => data.json());});const promiseActor = createActor(promiseLogic);promiseActor.subscribe((snapshot) => {  console.log(snapshot);});promiseActor.start();// => {//   output: undefined,//   status: 'active'//   ...// }// After promise resolves// => {//   output: { ... },//   status: 'done',//   ...// }
Learn more about promise actors.
Transition function logic (fromTransition(...))​
Transition actor logic is described by a transition function, similar to a reducer. Transition functions take the current state and received event object as arguments, and return the next state. Actors created from transition logic (“transition actors”) can:

Receive events
Emit snapshots of its state

const transitionLogic = fromTransition(  (state, event) => {    if (event.type === 'increment') {      return {        ...state,        count: state.count + 1,      };    }    return state;  },  { count: 0 },);const transitionActor = createActor(transitionLogic);transitionActor.subscribe((snapshot) => {  console.log(snapshot);});transitionActor.start();// => {//   status: 'active',//   context: { count: 0 },//   ...// }transitionActor.send({ type: 'increment' });// => {//   status: 'active',//   context: { count: 1 },//   ...// }
Learn more about transition actors.
Observable logic (fromObservable(...))​
Observable actor logic is described by an observable stream of values. Actors created from observable logic (“observable actors”) can:

Emit snapshots of the observable’s emitted value

Sending events to observable actors will have no effect.
import { interval } from 'rxjs';const secondLogic = fromObservable(() => interval(1000));const secondActor = createActor(secondLogic);secondActor.subscribe((snapshot) => {  console.log(snapshot.context);});secondActor.start();// At every second:// Logs 0// Logs 1// Logs 2// ...
Learn more about observable actors.
Event observable logic (fromEventObservable(...))​
Event observable actor logic is described by an observable stream of event objects. Actors created from event observable logic (“event observable actors”) can:

Implicitly send events to its parent actor
Emit snapshots of its emitted event objects

Sending events to event observable actors will have no effect.
import { setup, fromEventObservable } from 'xstate';import { fromEvent } from 'rxjs';const mouseClickLogic = fromEventObservable(() =>  fromEvent(document.body, 'click') as Subscribable<EventObject>);const canvasMachine = setup({  actors: {    mouseClickLogic  }}).createMachine({  invoke: {    // Will send mouse click events to the canvas actor    src: 'mouseClickLogic',  },});const canvasActor = createActor(canvasMachine);canvasActor.start();
Learn more about observable actors.
Callback logic (fromCallback(...))​
Callback actor logic is described by a callback function that receives a single object argument that includes a sendBack(event) function and a receive(event => ...) function. Actors created from callback logic (“callback actors”) can:

Receive events via the receive function
Send events to the parent actor via the sendBack function

const callbackLogic = fromCallback(({ sendBack, receive }) => {  let lockStatus = 'unlocked';  const handler = (event) => {    if (lockStatus === 'locked') {      return;    }    sendBack(event);  };  receive((event) => {    if (event.type === 'lock') {      lockStatus = 'locked';    } else if (event.type === 'unlock') {      lockStatus = 'unlocked';    }  });  document.body.addEventListener('click', handler);  return () => {    document.body.removeEventListener('click', handler);  };});
Callback actors are a bit different from other actors in that they do not do the following:

Do not work with onDone
Do not produce a snapshot using .getSnapshot()
Do not emit values when used with .subscribe()
Can not be stopped with .stop()

You may choose to use sendBack to report caught errors to the parent actor. This is especially helpful for handling promise rejections within a callback function, which will not be caught by onError.
Callback functions cannot be async functions. But it is possible to execute a Promise within a callback function.
import { setup, fromCallback } from 'xstate';const someCallback = fromCallback(({ sendBack }) => {  somePromise()    .then((data) => sendBack({ type: 'done', data }))    .catch((error) => sendBack({ type: 'error', data: error }));  return () => {    /* cleanup function */  };})const machine = setup({  actors: {    someCallback  }}).createMachine({  initial: 'running',  states: {    running: {      invoke: {        src: 'someCallback',      },      on: {        error: {          actions: ({ event }) => console.error(event.data),        },      },    },  },});
Learn more about callback actors.
Actors as promises​
You can create a promise from any actor by using the toPromise(actor) function. The promise will resolve with the actor snapshot's .output when the actor is done (snapshot.status === 'done') or reject with the actor snapshot's .error when the actor is errored (snapshot.status === 'error').
import { createMachine, createActor, toPromise } from 'xstate';const machine = createMachine({  // ...  states: {    // ...    done: { type: 'final' }  },  output: {    count: 42  }});const actor = createActor(machine);actor.start();// Creates a promise that resolves with the actor's output// or rejects with the actor's errorconst output = await toPromise(actor);console.log(output);// => { count: 42 }
If the actor is already done, the promise will resolve with the actor's snapshot.output immediately. If the actor is already errored, the promise will reject with the actor's snapshot.error immediately.
Higher-level actor logic​
Higher-level actor logic enhances existing actor logic with additional functionality. For example, you can create actor logic that logs or persists actor state:
import { fromTransition, type AnyActorLogic } from 'xstate';const toggleLogic = fromTransition((state, event) => {  if (event.type === 'toggle') {    return state === 'paused' ? 'playing' : 'paused';  }  return state;}, 'paused');function withLogging<T extends AnyActorLogic>(actorLogic: T) {  const enhancedLogic = {    ...actorLogic,    transition: (state, event, actorCtx) => {      console.log('State:', state);      return actorLogic.transition(state, event, actorCtx);    },  } satisfies T;  return enhancedLogic;}const loggingToggleLogic = withLogging(toggleLogic);
Custom actor logic​
Custom actor logic can be defined with an object that implements the ActorLogic interface.
For example, here is a custom actor logic object with a transition function that operates as a simple reducer:
import { createActor, EventObject, ActorLogic, Snapshot } from "xstate";const countLogic: ActorLogic<  Snapshot<undefined> & { context: number },  EventObject> = {  transition: (state, event) => {    if (event.type === 'INC') {      return {        ...state,        context: state.context + 1      };    } else if (event.type === 'DEC') {      return {        ...state,        context: state.context - 1      };    }    return state;  },  getInitialSnapshot: () => ({    status: 'active',    output: undefined,    error: undefined,    context: 0  }),  getPersistedSnapshot: (s) => s};const actor = createActor(countLogic)actor.subscribe(state => {  console.log(state.context)})actor.start() // => 0actor.send({ type: 'INC' }) // => 1actor.send({ type: 'INC' }) // => 2
For further examples, see implementations of ActorLogic in the source code, like the fromTransition actor logic creator, or the examples in the tests.
Empty actors​
Actor that does nothing and only has a single emitted snapshot: undefined
In XState, an empty actor is an actor that does nothing and only has a single emitted snapshot: undefined.
This is useful for testing, such as stubbing out an actor that is not yet implemented. It can also be useful in framework integrations, such as @xstate/react, where an actor may not be available yet:
import { createEmptyActor, AnyActorRef } from 'xstate';import { useSelector } from '@xstate/react';const emptyActor = createEmptyActor();function Component(props: { actor?: AnyActorRef }) {  const data = useSelector(    props.actor ?? emptyActor,    (snapshot) => snapshot.context.data,  );  // data is `undefined` if `props.actor` is undefined  // Otherwise, it is the data from the actor  // ...}
Actors and TypeScript​
XState v5 requires TypeScript version 5.0 or greater.For best results, use the latest TypeScript version. Read more about XState and TypeScript
You can strongly type the actors of your machine in the types.actors property of the machine config.
const fetcher = fromPromise(  async ({ input }: { input: { userId: string } }) => {    const user = await fetchUser(input.userId);    return user;  },);const machine = setup({  types: {    children: {} as {      fetch1: 'fetcher';      fetch2: 'fetcher';    }  }  actors: { fetcher }}).createMachine({  invoke: {    src: 'fetchData', // strongly typed    id: 'fetch2', // strongly typed    onDone: {      actions: ({ event }) => {        event.output; // strongly typed as { result: string }      },    },    input: { userId: '42' }, // strongly typed  },});
Testing​
The general strategy for testing actors is to send events and assert that the actor reaches an expected state, which can be observed either by:

Subscribing to its emitted snapshots via actor.subscribe(...)
Or reading the latest snapshot via actor.getSnapshot().

test('some actor', async () => {  const actor = createActor(fromTransition((state, event) => {    if (event.type === 'inc') {      return { count: state.count + 1 }    }    return state;  }, { count: 0 }));  // Start the actor  actor.start();  // Send event(s)  actor.send({ type: 'inc' });  actor.send({ type: 'inc' });  actor.send({ type: 'inc' });  // Assert the expected result  expect(actor.getSnapshot().context).toEqual({ count: 3 });});
Actors cheatsheet​
Cheatsheet: create an actor​
import { createActor } from 'xstate';import { someActorLogic } from './someActorLogic.ts';// Create an actor from the actor logicconst actor = createActor(someActorLogic);// Subscrube to an actor’s snapshot values and log themactor.subscribe((snapshot) => {  console.log(snapshot);});// Start the actor systemactor.start();// Now the actor can receive eventsactor.send({ type: 'someEvent' });// Stops the root actor, actor system, and actors in the systemactor.stop();
Cheatsheet: state machine logic​
import { createMachine, createActor } from 'xstate';const toggleMachine = createMachine({  id: 'toggle',  initial: 'inactive',  states: {    inactive: {},    active: {},  },});const toggleActor = createActor(toggleMachine);toggleActor.subscribe((snapshot) => {  // snapshot is the machine’s state  console.log('state', snapshot.value);  console.log('context', snapshot.context);});toggleActor.start();// Logs 'inactive'toggleActor.send({ type: 'toggle' });// Logs 'active'
Cheatsheet: promise logic​
import { fromPromise, createActor } from 'xstate';const promiseLogic = fromPromise(() => {  return fetch('https://example.com/...').then((data) => data.json());});const promiseActor = createActor(promiseLogic);promiseActor.subscribe((snapshot) => {  console.log(snapshot);});promiseActor.start();
Cheatsheet: transition function logic​
import { fromTransition, createActor } from 'xstate';const transitionLogic = fromTransition(  (state, event) => {    if (event.type === 'increment') {      return {        ...state,        count: state.count + 1,      };    }    return state;  },  { count: 0 },);const transitionActor = createActor(transitionLogic);transitionActor.subscribe((snapshot) => {  console.log(snapshot);});transitionActor.start();// => {//   status: 'active',//   context: { count: 0 },//   ...// }transitionActor.send({ type: 'increment' });// => {//   status: 'active',//   context: { count: 1 },//   ...// }
Cheatsheet: observable logic​
import { fromObservable, createActor } from 'xstate';import { interval } from 'rxjs';const secondLogic = fromObservable(() => interval(1000));const secondActor = createActor(secondLogic);secondActor.subscribe((snapshot) => {  console.log(snapshot.context);});secondActor.start();// At every second:// Logs 0// Logs 1// Logs 2// ...
Cheatsheet: event observable logic​
import { setup, fromEventObservable, createActor } from 'xstate';import { fromEvent } from 'rxjs';const mouseClickLogic = fromEventObservable(() =>  fromEvent(document.body, 'click') as Subscribable<EventObject>);const canvasMachine = setup({  actors: {    mouseClickLogic  }}).createMachine({  invoke: {    // Will send mouse click events to the canvas actor    src: 'mouseClickLogic',  },});const canvasActor = createActor(canvasMachine);canvasActor.start();
Cheatsheet: callback logic​
import { fromCallback, createActor } from 'xstate';const callbackLogic = fromCallback(({ sendBack, receive }) => {  let lockStatus = 'unlocked';  const handler = (event) => {    if (lockStatus === 'locked') {      return;    }    sendBack(event);  };  receive((event) => {    if (event.type === 'lock') {      lockStatus = 'locked';    } else if (event.type === 'unlock') {      lockStatus = 'unlocked';    }  });  document.body.addEventListener('click', handler);  return () => {    document.body.removeEventListener('click', handler);  };});

State machine actorsState machine actors are actors whose logic is represented by a finite state machine or statechart.
This page is just an overview on using state machines to represent actor logic. Read the documentation on state machines to learn about state machines in depth.
State machine actor capabilities​
CapabilityNotes✅Receive eventsState machine actors can receive events directly (actor.send(event)) or from other actors.✅Send eventsState machine actors can send events to other actors it has reference to.✅Spawn actorsState machine actors can spawn/invoke actors and have child actors.✅InputYou can provide input to state machine actors.✅OutputState machine actors can produce output.
State machine actor logic​
You can define state machine actor logic using the createMachine(...) actor logic creator, which takes a finite state machine or statechart configuration object as its only argument.
import { createMachine, createActor } from 'xstate';const toggleMachine = createMachine({  initial: 'inactive',  states: {    inactive: {      on: {        toggle: {          target: 'active'        }      }    },    active: {      on: {        toggle: {          target: 'inactive'        }      }    }  }});const toggleActor = createActor(toggleMachine);toggleActor.subscribe(snapshot => {  console.log(snapshot.value); // 'inactive' or 'active'});toggleActor.start();// logs 'inactive'toggleActor.send({ type: 'toggle' });// logs 'active'toggleActor.send({ type: 'toggle' });// logs 'inactive'
State machine actor input​
You can pass in input to a state machine actor by passing it to the createActor(...) function as the input property of the second argument. In the state machine (setupFiles(…).createMachine(…)), you read the input property of the first argument passed to the context function:
import { setup, createActor } from 'xstate';const feedbackMachine = setup({  // ...}).createMachine({  context: ({ input }) => ({    rating: input.defaultRating  }),  initial: 'question',  states: {    question: {/* ... */},    // ...  }});const feedbackActor = createActor(feedbackMachine, {  input: {    defaultRating: 3  }});feedbackActor.subscribe(snapshot => {  console.log(snapshot.context);});feedbackActor.start();// logs { rating: 3 }
State machine actor output​
Read state machine output for more information.

Promise actorsPromise actors are actors that represent a promise that performs some asynchronous task. They may resolve with some output, or reject with an error.
Promise actor capabilities​
CapabilityNotes❌Receive eventsPromise actors currently do not receive events.✅Send eventsPromise actors can send events to other actors it has reference to, such as those provided in its input.❌Spawn actorsPromise actors currently cannot spawn new actors.✅InputYou can provide input to promise actors.✅OutputPromise actors can produce output, which is the resolved value of the promise.
Promise actor logic​
You can define promise actor logic using the fromPromise(...) actor logic creator, which takes a function that returns a promise and returns actor logic that can be used to create promise actors.
import { fromPromise, createActor } from 'xstate';async function getUser(id: string) {  // ...  return { id, /* other user data */ };}const promiseLogic = fromPromise(async () => {  const user = await getUser('123');  return user;});const promiseActor = createActor(promiseLogic);promiseActor.subscribe(snapshot => {  console.log(snapshot.status, snapshot.output);});promiseActor.start();// logs 'active', undefined// ... (after some time)// logs 'done', { id: '123', /* other user data */ }
Promise actor input​
You can pass in input to a promise actor by passing it to the createActor(...) function as the input property of the second argument. In the promise logic (fromPromise(promiseFn)), you read the input property of the first argument passed to the promise function:
import { fromPromise, createActor } from 'xstate';const promiseLogic = fromPromise(async ({ input }) => {  const user = await getUser(input.id);  return user;});const promiseActor = createActor(promiseLogic, {  input: { id: '123' }});
The input type is inferred from the promise function's first argument type. You can also provide an explicit input type in the second generic parameter:
import { fromPromise } from 'xstate';interface User {  name: string;  id: string;}const secondLogic = fromPromise(async ({ input }: { input: { id: string }}) => {  const user = await getUser(input.id); // User is inferred  return user;});const firstLogic = fromPromise<User, { id: string }>(async ({ input, self, /* ... */ }) => {  const user = await getUser(input.id);  return user;});
Promise actor output​
To get the eventual resolved output of a promise actor, you can subscribe to the promise actor and check the status property of the snapshot. If the status is 'done', you can access the output property of the snapshot to get the resolved value. Otherwise, the output will be undefined.
import { fromPromise } from 'xstate';const promiseLogic = fromPromise(async () => {  const user = await getUser('123');  return user;});const promiseActor = createActor(promiseLogic);promiseActor.subscribe(snapshot => {  if (snapshot.status === 'done') {    console.log(snapshot.output);    // logs { id: '123', /* other user data */ }  }});
You can also use toPromise(...) to convert any actor, including promise actors, to a promise. This is useful if you want to await the output of an actor:
import { toPromise, createActor } from 'xstate';import { somePromiseLogic } from './somePromiseLogic';const promiseActor = createActor(somePromiseLogic);promiseActor.start();const output = await toPromise(promiseActor);console.log(output);// logs the resolved output of the promise actor
Promise actor error handling​
If an error occurs in the promise logic, the promise actor will reject with the error. You can subscribe to the promise actor and check the status property of the snapshot in an error observer (the error property of the observer object).
import { fromPromise } from 'xstate';const promiseLogic = fromPromise(async () => {  // ...  throw new Error('Something went wrong');});const promiseActor = createActor(promiseLogic);promiseActor.subscribe({  error: (error) => {    console.error(error);    // logs 'Error: Something went wrong'  }});promiseActor.start();
Stopping promise actors​
You can stop a promise actor created using createActor(promiseLogic) by calling .stop() on the actor instance. This will discard the resolved or rejected value of the promise and dispose of any subscriptions to the promise actor.
You can also abort a promise actor by passing the signal to it:
import { fromPromise, createActor } from 'xstate';const promiseLogic = fromPromise(async ({  input,  signal}) => {  // Pass the signal to abort fetching if signaled  const data = await fetch('/some/url', { signal });  return data;});const promiseActor = createActor(promiseLogic);promiseActor.start();// ...// Abort the promise actorpromiseActor.stop();

Transition ActorsTransition actors are actors whose logic is represented by a state-transition function, which is a function that returns the next state of an actor given:

The current state of the actor
The event that triggered the transition

This is very similar to a reducer function in libraries like Redux.
Transition actor capabilities​
CapabilityNotes✅Receive eventsTransition actors receive events to modify its state.✅Send eventsTransition actors can send events to other actors it has reference to, such as those provided in its input. Note that doing this would be impure.❌Spawn actorsTransition actors currently cannot spawn new actors.✅InputYou can provide input to transition actors.❌OutputTransition actors currently do not produce output – they are active indefinitely until they are stopped or an error occurs.
Transition actor logic​
You can define transition actor logic using the fromTransition(...) actor logic creator, which takes two arguments:

A state-transition function that returns the next state of the actor
An initial state for the actor

The actor logic creator returns actor logic that can be used to create transition actors.
import { fromTransition, createActor } from 'xstate';const countLogic = fromTransition((state, event) => {  switch (event.type) {    case 'increment': {      return { count: state.count + 1 };    }    case 'decrement': {      return { count: state.count - 1 };    }    default: {      return state;    }  }}, { count: 0 }); // Initial stateconst countActor = createActor(countLogic);countActor.subscribe(snapshot => {  console.log(snapshot.context);});countActor.start();// logs { count: 0 }countActor.send({ type: 'increment' });// logs { count: 1 }countActor.send({ type: 'decrement' });// logs { count: 0 }
Transition actor input​
You can pass in input to a transition actor, which will be passed to the function that resolves the initial state.
import { fromTransition, createActor } from 'xstate';const countLogic = fromTransition((state, event) => {  // ...}, ({ input }: { input: number }) => ({  count: input  // Initial state}));const countActor = createActor(countLogic, {  input: 42});countActor.subscribe(snapshot => {  console.log(snapshot.context);  // logs { count: 42 }});countActor.start();

Callback ActorsCallback actors are actors whose logic is represented by a function that can "callback" to the parent actor by sending events (via sendBack(...)). It can also receive(...) events from other actors.
Callback actor capabilities​
CapabilityNotes✅Receive eventsCallback actors can receive events via the receive(event => {...}) function.✅Send eventsCallback actors can send events to its parent via sendBack(event), or to other actors it has reference to, such as those provided in its input.❌Spawn actorsCallback actors currently cannot spawn new actors.✅InputYou can provide input to callback actors.❌OutputCallback actors currently do not produce output – they are active indefinitely until they are stopped or an error occurs.
Callback actor logic​
You can define callback actor logic using the fromCallback(...) actor logic creator, which takes a callback function and returns actor logic that can be used to create callback actors.
import { createActor, createMachine, fromCallback, sendTo, setup } from 'xstate';const resizeLogic = fromCallback(({ sendBack, receive }) => {  const resizeHandler = (event) => {    sendBack(event);  };  window.addEventListener('resize', resizeHandler);  const removeListener = () => {    window.removeEventListener('resize', resizeHandler);  }  receive(event => {    if (event.type === 'stopListening') {      console.log('Stopping listening');      removeListener();    }  })  // Cleanup function  return () => {    console.log('Cleaning up');    removeListener();  }});const machine = setup({  actors: {    resizeLogic  }}).createMachine({  invoke: {    id: 'resize',    src: 'resizeLogic'  },  on: {    stop: {      actions: sendTo('resize', { type: 'stopListening' })    }  }});const actor = createActor(machine);actor.start();actor.send({ type: 'stop' });// logs "Stopping listening" from callback actoractor.stop();// logs "Cleaning up" from callback actor
Callback actor input​
You can pass input when creating callback actors, which is passed to the callback actor logic in the input property of the first argument.
import {  fromCallback,  createActor,  setup,  type EventObject} from 'xstate';const resizeLogic = fromCallback<EventObject, { defaultSize: number }>(({  sendBack,  receive,  input // Typed as { defaultSize: number }}) => {  input.defaultSize; // 100  // ...});const machine = setup({  actors: {    resizeLogic  }}).createMachine({  // ...  invoke: {    src: 'resizeLogic',    input: {      defaultSize: 100    }  }});

Observable ActorsObservable actors are actors that represent an observable stream of values. This makes it easy to interop with observable libraries like RxJS.
All XState actors are observable.
Observable actor capabilities​
CapabilityNotes❌Receive eventsObservable actors do not currently receive events.✅Send eventsObservable actors can send events to other actors it has reference to, such as those provided in its input.❌Spawn actorsObservable actors currently cannot spawn new actors.✅InputYou can provide input to observable actors.❌OutputObservable actors currently do not produce output – they are active indefinitely until they are stopped, completed, or an error occurs.
Observable actor logic​
You can define observable actor logic using the fromObservable(...) actor logic creator, which takes a function that returns an observable and returns actor logic that can be used to create observable actors.
import { fromObservable, createActor } from 'xstate';import { interval } from 'rxjs';const intervalLogic = fromObservable(() => interval(1000));const intervalActor = createActor(intervalLogic);intervalActor.subscribe(snapshot => {  console.log(snapshot.context);});intervalActor.start();// logs 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...// every second
Observable actor input​
You can pass in input to an observable actor by passing it to the createActor(...) function as the input property of the second argument. In the observable logic (fromObservable(observableFn)), you read the input property of the first argument passed to the observable function:
import { fromObservable, createActor } from 'xstate';import { interval } from 'rxjs';const intervalLogic = fromObservable(({ input }) => interval(input.interval));const intervalActor = createActor(intervalLogic, {  input: { interval: 10_000 }});intervalActor.subscribe(snapshot => {  console.log(snapshot.context);});intervalActor.start();// logs 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...// every 10 seconds

InvokeState machines can “invoke” one or many actors within a given state. The invoked actor will start when the state is entered, and stop when the state is exited. Any XState actor can be invoked, including simple Promise-based actors, or even complex machine-based actors.
Invoking an actor is useful for managing synchronous or asynchronous work that the state machine needs to orchestrate and communicate with at a high level, but doesn't need to know about in detail.
Read about the difference between invoking and spawning actors.
<a href="https://stately.ai/registry/editor/embed/c447d996-cef1-421d-a422-8be695668764?machineId=7f8f7dfb-f9a0-4e37-9c2a-bbca9f093d21&amp;mode=design">View the <em></em> machine in Stately Studio</a>.
You can visualize your state machines and easily invoke actors in our drag-and-drop Stately editor. Read more about actors in Stately’s editor.
Actors can be invoked within any state except for the top-level final state. In the following example, the loading state invokes a Promise-based actor:
import { setup, createActor, fromPromise, assign } from 'xstate';const fetchUser = (userId: string) =>  fetch(`https://example.com/${userId}`).then((response) => response.text());const userMachine = setup({  types: {    context: {} as {      userId: string;      user: object | undefined;      error: unknown;    }  },  actors: {    fetchUser: fromPromise(async ({ input }) => {      const user = await fetchUser(input.userId);            return user;    })  }}).createMachine({  id: 'user',  initial: 'idle',  context: {    userId: '42',    user: undefined,    error: undefined,  },  states: {    idle: {      on: {        FETCH: { target: 'loading' },      },    },    loading: {      invoke: {        id: 'getUser',        src: 'fetchUser',        input: ({ context: { userId } }) => ({ userId }),        onDone: {          target: 'success',          actions: assign({ user: ({ event }) => event.output }),        },        onError: {          target: 'failure',          actions: assign({ error: ({ event }) => event.error }),        },      },    },    success: {},    failure: {      on: {        RETRY: { target: 'loading' },      },    },  },});
Actors can also be invoked on the root of the machine, and they will be active for the lifetime of their parent machine actor:
import { fromEventObservable, fromEvent } from 'rxjs';const interactiveMachine = createMachine({  invoke: {    src: fromEventObservable(      () => fromEvent(document.body, 'click') as Subscribable<EventObject>,    ),  },  on: {    click: {      actions: ({ event }) => console.log(event),    },  },});
And invoke can be an array, to invoke multiple actors:
const vitalsWorkflow = createMachine({  states: {    CheckVitals: {      invoke: [        { src: 'checkTirePressure' },        { src: 'checkOilPressure' },        { src: 'checkCoolantLevel' },        { src: 'checkBattery' },      ],    },  },});
For further examples, see:

Reusing function and event definitions workflow
Check inbox periodically (cron-based workflow)
Car vitals checks (SubFlow Repeat) workflow

How are actors different from actions?​
Actions are “fire-and-forget”; as soon as their execution starts, the state machine running the actions forgets about them. If you specify an action as async, the action won’t be awaited before moving to the next state. Remember: transitions are always zero-time (states transition synchronously).
Invoked actors can do asynchronous work and communicate with their parent machine actor. They can send and receive events. Invoked machine actors can even invoke or spawn their own child actors.
Unlike actions, errors thrown by invoked actors can be handled directly:
invoke: {  src: 'fetchUser',  onError: {    target: 'failure',    actions: assign({ error: ({ event }) => event.error })  }}
Whereas errors thrown by actions can only be handled globally by a subscriber of their parent state machine:
actor.subscribe({  error: (err) => {    console.error(err);  },});
Lifecycle​
Invoked actors have a lifecycle that is managed by the state they are invoked in. They are created and started when the state is entered, and stopped when the state is exited.
If a state is entered and then immediately exited, e.g. due to an eventless ("always") transition, then no actors will be invoked on that state.
Re-entering​
By default, when a state machine transitions from a parent state to the same parent state or a descendent (child or deeper), it will not re-enter the parent state. Because the transition is not re-entering, the parent state's existing invoked actors will not be stopped and new invoked actors will not be started.
However, if you want a transition to re-enter the parent state, set the transition's reenter property to true. Transitions that re-enter the state will stop existing invoked actors and start new invoked actors.
Read more about re-entering states.
The invoke property API​
An invocation is defined in a state node's configuration with the invoke property, whose value is an object that contains:

src - The source of the actor logic to invoke when creating the actor, or a string referring to actor logic defined in the machine's provided implementation.
id - A string identifying the actor, unique within its parent machine.
input - The input to pass to the actor.
onDone - Transition that occurs when the actor is complete.
onError - Transition that occurs when the actor throws an error.
onSnapshot - Transition that occurs when the actor emits a new value.
systemId - A string identifing the actor, unique system-wide.

Source​
The src represents the actor logic the machine should use when creating the actor. There are several actor logic creators available in XState:

State machine logic (createMachine)
Promise logic (fromPromise), where invoke will take the onDone transition on resolve, or the onError transition on reject
Transition function logic (fromTransition), which follows the reducer pattern
Observable logic (fromObservable), which can send events to the parent machine, and where invoke will take an onDone transition when completed
Event observable logic (fromEventObservable), like Observable logic but for streams of event objects
Callback logic (fromCallback), which can send events to and receive events from the parent machine

The invoke src can be inline or provided.
Inline src​
Either directly inline:
invoke: {  src: fromPromise(…)}
Or from some logic in the same scope as the machine:
const logic = fromPromise(…)const machine = createMachine({  // …  invoke: {    src: logic  }});
Provided src​
The src can be provided in the machine implementation and referenced using a string or an object.
const machine = createMachine({  // …  invoke: {    src: 'workflow', // string reference  },});const actor = createActor(  machine.provide({    actors: {      workflow: fromPromise(/* ... */), // provided    },  }),);
onDone​

Transitions when invoked actor is complete
Event object output property is provided with actor's output data
Not available for callback actors

Don't get the onDone property on a state confused with invoke.onDone - they are similar transitions, but refer to different things.
The onDone property on a state node refers to the compound state node reaching a final state.
The invoke.onDone property refers to the invocation (invoke.src) being done.
// ...loading: {  invoke: {    src: someSrc,    // refers to `someSrc` being done    onDone: {/* ... */}  },  initial: 'loadFoo',  states: {    loadFoo: {/* ... */},    loadBar: {/* ... */},    loadingComplete: { type: 'final' }  },  // refers to 'loading.loadingComplete' being reached  onDone: { target: 'loaded' }}// ...
The onError transition can be an object:
{  invoke: {    src: 'fetchItem',    onDone: {      target: 'success',      actions: ({ event }) => {        console.log(event.output);      }    },    onError: {      target: 'error',      actions: ({ event }) => {        console.error(event.error);      }    }  }}
Or, for simplicity, target-only transitions can be strings:
{  invoke: {    src: 'fetchItem',    onDone: 'success',    onError: 'error'  }}
onError​

Transitions when invoked actor throws an error, or (for Promise-based actors) when the promise rejects
Event object error property is provided with actor’s error data

invoke: {  src: 'getUser',  onError: {    target: 'failure',    actions: ({ event }) => {      console.error(event.error);    }  }}
Or, for simplicity, target-only transitions can be strings:
{  invoke: {    src: 'getUser',    onError: 'failure'  }}
onSnapshot​

Transitions when invoked actor emits a new snapshot
Event gets snapshot with actor's snapshot
Not available for callback actors

invoke: {  src: 'getUser',  onSnapshot: {    actions: ({ event }) => console.log(event.snapshot)  }}
Read more about actor snapshots.
Input​
To define input to an invoked actor, use input.
The input property can be a static input value, or a function that returns the input value. The function will be passed an object that contains the current context and event.
Behind the scenes, input is conveyed to the actor by an event:
{ type: 'xstate.init', input: ... }.
Input from a static value​
invoke: {  src: 'liveFeedback',  input: {    domain: 'stately.ai'  }}
Input from a function​
invoke: {  src: fromPromise(({ input: { endpoint, userId } }) => {    return fetch(`${endpoint}/${userId}`).then((res) => res.json());  }),  input: ({ context, event }) => ({    endpoint: context.endpoint,    userId: event.userId  })}
See Input for more.
Invoking Promises​
The most common type of actors you’ll invoke are promise actors. Promise actors allow you to await the result of a promise before deciding what to do next.
XState can invoke Promises as actors using the fromPromise actor logic creator. Promises can:

resolve(), which will take the onDone transition
reject() (or throw an error), which will take the onError transition

If the state where the invoked promise is active is exited before the promise settles, the result of the promise is discarded.
import { setup, createActor, fromPromise, assign } from 'xstate';// Function that returns a Promise// which resolves with some useful value// e.g.: { name: 'David', location: 'Florida' }const fetchUser = (userId: string) =>  fetch(`/api/users/${userId}`).then((response) => response.json());const userMachine = setup({  types: {    context: {} as {      userId: string;      user: object | undefined;      error: unknown;    }  }}).createMachine({  id: 'user',  initial: 'idle',  context: {    userId: '42',    user: undefined,    error: undefined,  },  states: {    idle: {      on: {        FETCH: { target: 'loading' },      },    },    loading: {      invoke: {        id: 'getUser',        src: fromPromise(({ input }) => fetchUser(input.userId)),        input: ({ context: { userId } }) => ({ userId }),        onDone: {          target: 'success',          actions: assign({ user: ({ event }) => event.output }),        },        onError: {          target: 'failure',          actions: assign({ error: ({ event }) => event.error }),        },      },    },    success: {},    failure: {      on: {        RETRY: { target: 'loading' },      },    },  },});
The resolved output is placed into a 'xstate.done.actor.<id>' event, under the output property, e.g.:
{  type: 'xstate.done.actor.getUser',  output: {    name: 'David',    location: 'Florida'  }}
Promise Rejection​
If a Promise rejects, the onError transition will be taken with a { type: 'xstate.error.actor.<id>' } event. The error data is available on the event's error property:
import { setup, createActor, fromPromise, assign } from 'xstate';const search = (query: string) =>  new Promise((resolve, reject) => {    if (!query.length) {      return reject('No query specified');      // or:      // throw new Error('No query specified');    }    return resolve(getSearchResults(query));  });// ...const searchMachine = setup({  types: {    context: {} as {      results: object | undefined;      errorMessage: unknown;    }  }}).createMachine({  id: 'search',  initial: 'idle',  context: {    results: undefined,    errorMessage: undefined,  },  states: {    idle: {      on: {        SEARCH: { target: 'searching' },      },    },    searching: {      invoke: {        id: 'search',        src: fromPromise(({ input: { query } }) => search(query)),        input: ({ event }) => ({ query: event.query }),        onError: {          target: 'failure',          actions: assign({            errorMessage: ({ context, event }) => {              // event is:              // { type: 'xstate.error.actor.<id>', error: 'No query specified' }              return event.error;            },          }),        },        onDone: {          target: 'success',          actions: assign({ results: ({ event }) => event.output }),        },      },    },    success: {},    failure: {},  },});
If the onError transition is missing, and the Promise is rejected, the error will throw. However, you can handle all thrown errors for an actor by subscribing an observer object with an error function:
actor.subscribe({  error: (err) => { ... }})
Invoking Callbacks​
You can invoke callback actor logic by:

Setting up the callback actor logic in the actors object of the setup({ actors: { ... } }) call
Invoking the callback actor logic by its source name (src) in the invoke property of a state

import { setup, fromCallback } from 'xstate';const machine = setup({  actors: {    someCallback: fromCallback(({ input, sendBack, receive }) => {      // ...    })  }}).createMachine({  // ...  invoke: {    src: 'someCallback',    input: {/* ... */}  }});
Read callback actor logic for more information on callback actors.
Invoking Observables​
You can invoke observable logic by:

Setting up the observable logic in the actors object of the setup({ actors: { ... } }) call
Invoking the observable logic by its source name (src) in the invoke property of a state

import { setup, fromObservable } from 'xstate';import { interval } from 'rxjs';const machine = setup({  actors: {    someObservable: fromObservable(({ input }: { input: number }) => {      return interval(input.ms);    })  }}).createMachine({  // ...  invoke: {    src: 'someObservable',    input: { ms: 1000 },    onSnapshot: {      actions: ({ event }) => {        console.log(event.snapshot.context); // 1, 2, 3, ...      }    }  }});
Read observable actor logic for more information on observable actors.
Invoking Event Observables​
You can invoke event observables by using the fromEventObservable(...) actor logic creator. Event observable logic is similar to observable logic in that the parent actor subscribes to the event observable; however, the emitted values of an event observable are expected to be events that are sent to the invoking (parent) actor directly.
import { setup, fromEventObservable } from 'xstate';const mouseClicks = fromEventObservable(/* ... */);const machine = setup({  actors: {    mouseClicks  }}).createMachine({  // ...  invoke: {    src: 'mouseClicks'    // No `onSnapshot` or `onDone` needed; events are sent directly to    // the machine actor  },  on: {    // Sent by the event observable actor    click: {      // ...    }  }})
Invoking Transitions​
You can invoke transition actor logic by:

Setting up the transition actor logic in the actors object of the setup({ actors: { ... } }) call
Invoking the transition actor logic by its source name (src) in the invoke property of a state

import { setup, fromTransition } from 'xstate';const machine = setup({  actors: {    someTransition: fromTransition((state, event, { input }) => {      // ...      return state;    })  }}).createMachine({  // ...  invoke: {    src: 'someTransition',    input: {/* ... */},    onSnapshot: {      actions: ({ event }) => {        console.log(event.context);      }    }  }});
Read transition actor logic for more information on transition actors.
Invoking Machines​
You can invoke state machine actor logic by:

Setting up the state machine actor logic in the actors object of the setup({ actors: { ... } }) call
Invoking the state machine actor logic by its source name (src) in the invoke property of a state

import { setup } from 'xstate';const childMachine = setup({/* ... */}).createMachine({  context: ({ input }) => ({    // ...  }),  // ...});const machine = setup({  actors: {    someMachine: childMachine  }}).createMachine({  // ...  invoke: {    src: 'someMachine',    input: {/* ... */}  }});
Read state machine actor logic for more information on state machine actors.
Sending Responses​
An invoked actor (or spawned actor) can respond to another actor; i.e., it can send an event in response to an event sent by another actor. To do so, provide a reference to the sending actor as a custom property on the event object being sent. In the following example, we use event.sender, but any name works.
// Parentactions: sendTo('childActor', ({ self }) => ({  type: 'ping',  sender: self,}));// Childactions: sendTo(  ({ event }) => event.sender,  { type: 'pong' },);
In the following example, the 'client' machine below sends the 'CODE' event to the invoked 'auth-server' actor, which then responds with a 'TOKEN' event after 1 second.
import { createActor, createMachine, sendTo } from 'xstate';const authServerMachine = createMachine({  id: 'server',  initial: 'waitingForCode',  states: {    waitingForCode: {      on: {        CODE: {          actions: sendTo(            ({ event }) => event.sender,            { type: 'TOKEN' },            { delay: 1000 },          ),        },      },    },  },});const authClientMachine = createMachine({  id: 'client',  initial: 'idle',  states: {    idle: {      on: {        AUTH: { target: 'authorizing' },      },    },    authorizing: {      invoke: {        id: 'auth-server',        src: authServerMachine,      },      entry: sendTo('auth-server', ({ self }) => ({        type: 'CODE',        sender: self,      })),      on: {        TOKEN: { target: 'authorized' },      },    },    authorized: {      type: 'final',    },  },});
Note that by default sendTo will send events anonymously, in which case the reciever will not know the source of the event.
In XState v4, the respond(...) action creator was used for this purpose. In XState v5, use sendTo(...) instead.
Multiple Actors​
You can invoke multiple actors by specifying each in an array:
invoke: [  { id: 'actor1', src: 'someActor' },  { id: 'actor2', src: 'someActor' },  { id: 'logActor', src: 'logActor' },];
Each invocation will create a new instance of that actor, so even if the src of multiple actors are the same (e.g., someActor above), multiple instances of someActor will be invoked.
Testing​
You can test invoked actors by asserting that the parent actor receives expected events from the invoked actor.
const machine = setup({  actors: {    countLogic  }}).createMachine({  invoke: {    src: 'countLogic'  }})
Referencing Invoked Actors​
Actors can be read on snapshot.children.<actorId>. The returned value is an ActorRef object, with properties like:

id - the ID of the actor
send()
getSnapshot()

actor.subscribe({  next(snapshot) {    console.log(Object.keys(snapshot.children));  },});
snapshot.children is a key-value object where the keys are the actor ID and the value is the ActorRef.
Invoke and TypeScript​
XState v5 requires TypeScript version 5.0 or greater.For best results, use the latest TypeScript version. Read more about XState and TypeScript
You should the setup({ ... }) API to properly infer types for invoked actor logic.
import { setup, fromPromise, assign } from 'xstate';interface User {  id: string;  name: string;}const machine = setup({  actors: {    fetchUser: fromPromise<User, { userId: string }>(async ({ input }) => {      const response = await fetch(`https://example.com/${input.userId}`);      return response.json();    })  }}).createMachine({  // ...  context: {    user: null,    userId: 42  },  initial: 'idle',  states: {    idle: {      on: {        editUserDetails: { target: 'loadingUser' }      }    },    loadingUser: {      invoke: {        src: 'fetchUser',        input: ({ context }) => ({          userId: context.userId // Type enforced to be string        }),        onDone: {          actions: assign({            user: ({ event }) => event.output // Strongly typed as User          })        }      }    }  }});
Read the documentation on setting up state machines for more information.
Invoke cheatsheet​
Cheatsheet: invoke an actor​
import { setup, createActor, fromPromise, assign } from 'xstate';const fetchUser = (userId: string) =>  fetch(`https://example.com/${userId}`).then((response) => response.text());const userMachine = setup({  actors: {    getUser: fromPromise(async ({ input }: { input: { userId: string }}) => {      const data = await fetchUser(input.userId);      return data    })  }}).createMachine({  // …  states: {    idle: {      on: {        FETCH: { target: 'loading' },      },    },    loading: {      invoke: {        id: 'getUser',        src: 'getUser',        input: ({ context: { userId } }) => ({ userId }),        onDone: {          target: 'success',          actions: assign({ user: ({ event }) => event.output }),        },        onError: {          target: 'failure',          actions: assign({ error: ({ event }) => event.error }),        },      },    },    success: {},    failure: {      on: {        RETRY: { target: 'loading' },      },    },  },});
Cheatsheet: invoke an actor on the root of the machine​
import { createMachine } from 'xstate';import { fromEventObservable, fromEvent } from 'rxjs';const interactiveMachine = createMachine({  invoke: {    src: fromEventObservable(      () => fromEvent(document.body, 'click') as Subscribable<EventObject>,    ),  },  on: {    click: {      actions: ({ event }) => console.log(event),    },  },});
Cheatsheet: invoke multiple actors as an array​
import { createMachine } from 'xstate';const vitalsWorkflow = createMachine({  states: {    CheckVitals: {      invoke: [        { src: 'checkTirePressure', /* ... */ },        { src: 'checkOilPressure', /* ... */ },        { src: 'checkCoolantLevel', /* ... */ },        { src: 'checkBattery', /* ... */ },      ],    },  },});

SpawnSometimes invoking actors may not be flexible enough for your needs. For example, you might want to:

Invoke child machines that last across several states
Invoke a dynamic number of actors

You can do this by spawning an actor instead of invoking. Actors created by spawning are spawning actors, and actors created with invoke are invoking actors.
Read about the difference between spawning and invoking actors.
There are two ways to spawn: the spawnChild action creator, or the spawn helper function for assign.
In most cases, prefer spawnChild, which causes an actor to be spawned, and can accept a configurable ID for the actor to reference it later:
createMachine({  entry: spawnChild(childMachine, {    id: 'child'  })})
You can use spawnChild for multiple spawned actors:
createMachine({  entry: [    spawnChild(childMachine, { id: 'child-1' }),    spawnChild(childMachine, { id: 'child-2' }),    spawnChild(childMachine, { id: 'child-3' })  ]})
You can also use the spawn helper function provided by the assign action creator, which allows you to store a reference to the spawned actor (an ActorRef) in the machine's context:
const parentMachine = createMachine({  entry: [    assign({      childMachineRef: ({ spawn }) => spawn(childMachine, { id: 'child' })    })  ]});
However, if you use spawn, make sure you remove the ActorRef from context to prevent memory leaks when the spawned actor is no longer needed:
actions: [  stopChild('child'),  assign({ childMachineRef: undefined })]
You can spawn as many actors as you need:
const childMachine = createMachine({  /* ... */});const parentMachine = createMachine({  entry: [    assign({      childMachineRefs: ({ spawn }) => [        spawn(childMachine),        spawn(childMachine),        spawn(childMachine),      ],    }),  ],});
If you don’t need to keep track of a reference to the spawned actor (e.g.: for anonymous spawned actors), you can use the spawnChild action creator. It does not return a reference, but indicates to the XState interpreter that a new actor should be spawned:
createMachine({  entry: spawnChild('workflow', {    id: 'workflow'  })})
API​
actions: assign({  ref: ({ spawn }) => spawn(fromPromise(...), {    id: 'some-id',  })})

spawn(actorBehavior, options?)

actorBehavior - The behavior of the actor to spawn. This can be a function, promise, observable, or callback.
options - Options for spawning the actor.

id (optional) - The ID of the actor. This is used to reference the actor in the state machine.
input (optional) - The input to pass to the actor.
systemId (optional) - A string identifing the actor, unique system-wide.





Source​

Inline: spawn(fromPromise(...))
Referenced: spawn('getUser')

.provide({ actors })



Lifecycle​

Created & started when spawned
Stopped when the machine is stopped
Can be manually stopped

Stopping an actor​
You can stop a child actor via the "stop child" action. This action is created from the stopChild(id) action creator.
import { setup, stopChild, fromPromise } from 'xstate';const machine = setup({  actors: {    something: fromPromise(async () => {      // Some actor logic      return 'Some response';    })  }}).createMachine({  context: ({ spawn }) => ({    something: spawn('something', { id: 'thing' })  }),  // ...  on: {    'thing.stop': {      actions: stopChild('thing')    },    'thing.stopFromContext': {      actions: stopChild(({ context }) => context.something)    }  }});
Stopping a child actor does not remove it from context. To remove it from context, use the assign(...) action creator:
import { setup, stopChild } from 'xstate';const machine = setup({  // ...}).createMachine({  context: ({ spawn }) => ({    something: spawn('something', { id: 'thing' })  }),  // ...  on: {    'thing.stop': {      actions: [        stopChild('thing'),        assign({ something: undefined })      ]    }  }});
Spawn and TypeScript​
XState v5 requires TypeScript version 5.0 or greater.For best results, use the latest TypeScript version. Read more about XState and TypeScript
Coming soon
Spawn cheatsheet​
Coming soon

SystemsAn actor system is a collection of actors that can communicate with each other. Actors can invoke/spawn other actors, which forms a natural hierarchy of actors that belong to the same system.
In XState, a system is implicitly created from the root actor, which is the actor that is returned from createActor(machine).start(). The system can be accessed from the actor.system property of actors, and from the destructured { system } property from state machine actions:
import { createMachine, createActor } from 'xstate';const machine = createMachine({  entry: ({ system }) => {    // ...  },});const actor = createActor(machine).start();actor.system;
The root of a system can also be explicitly assigned a systemId in the createActor(...) function:
import { createActor } from 'xstate';const actor = createActor(machine, {  systemId: 'root-id',});actor.start();
This is useful for actors in the system to be able send events to the root actor.
Coming soon… systems in Stately Studio’s editor 🤫
Actor registration​
Actors can be registered with the system so that any other actor in the system can obtain a reference to it.
Invoked actors are registered with a system-wide systemId in the invoke object:
import { createMachine, createActor } from 'xstate';const formMachine = createMachine({  // ...  on: {    submit: {      actions: sendTo(({ system }) => system.get('notifier'), {        type: 'notify',        message: 'Form submitted!',      }),    },  },});const feedbackMachine = createMachine({  invoke: {    systemId: 'notifier',    src: notifierMachine,  },  // ...  states: {    // ...    form: {      invoke: formMachine,    },  },});const feedbackActor = createActor(feedbackMachine).start();
Spawned actors are registered with a system-wide systemId in the 2nd argument of the spawn function:
import { createMachine, createActor, assign } from 'xstate';const todoMachine = createMachine({  // ...});const todosMachine = createMachine({  // ...  on: {    'todo.add': {      actions: assign({        todos: ({ context, spawn }) => {          const newTodo = spawn(todoMachine, {            systemId: `todo-${context.todos.length}`,          });          return context.todos.concat(newTodo);        },      }),    },  },});
Actor communication​
You can also reference a specific actor from the system using system.get('actorId'):
Stopping a system​

Stop from root actor: actor.stop()
Cannot stop from descendant actors

Warning will be logged



Systems and TypeScript​
XState v5 requires TypeScript version 5.0 or greater.For best results, use the latest TypeScript version. Read more about XState and TypeScript

invoke.systemId
spawn(thing, { systemId })
system.get('actorId')
rootActor.stop()

System cheatsheet​
Cheatsheet: actor system​
import { createMachine, createActor } from 'xstate';const machine = createMachine({  entry: ({ system }) => {    // ...  },});const actor = createActor(machine).start();actor.system;
Cheatsheet: explicitly assign a systemId​
import { createActor } from 'xstate';const actor = createActor(machine, {  systemId: 'root-id',});actor.start();
Cheatsheet: register an invoked actor with the system​
import { createMachine, createActor } from 'xstate';const formMachine = createMachine({  // ...  on: {    submit: {      actions: sendTo(({ system }) => system.get('notifier'), {        type: 'notify',        message: 'Form submitted!',      }),    },  },});const feedbackMachine = createMachine({  invoke: {    systemId: 'notifier',    src: notifierMachine,  },  // ...  states: {    // ...    form: {      invoke: formMachine,    },  },});const feedbackActor = createActor(feedbackMachine).start();
Cheatsheet: register a spawned actor with the system​
import { createMachine, createActor, assign } from 'xstate';const todoMachine = createMachine({  // ...});const todosMachine = createMachine({  // ...  on: {    'todo.add': {      actions: assign({        todos: ({ context, spawn }) => {          const newTodo = spawn(todoMachine, {            systemId: `todo-${context.todos.length}`,          });          return context.todos.concat(newTodo);        },      }),    },  },});

InspectionThe Inspect API is a way to inspect the state transitions of your state machines and every aspect of actors in an actor system. Including:

Actor lifecycle
Actor event communication
Actor snapshot updates

We’ve recently released Stately Inspector, a universal tool that enables you to visually inspect the state of any application, frontend or backend, with the visualization of Stately’s editor.Learn more about Stately Inspector
The Inspect API lets you attach an “inspector,” an observer that observes inspection events, to the root of an actor system:
const actor = createActor(machine, {  inspect: (inspectionEvent) => {  // type: '@xstate.actor' or  // type: '@xstate.snapshot' or  // type: '@xstate.event'  console.log(inspectionEvent);  }});
The inspector will receive inspection events for every actor in the system, giving you granular visibility into everything happening, from how an individual actor is changing to how actors communicate with each other.
Inspection events​
Inspection events are event objects that have a type property that indicates the type of inspection event. There are three types of inspection events:

@xstate.actor for Actor inspection events
@xstate.event for Event inspection events
@xstate.snapshot for Snapshot inspection events

Actor inspection events​
The actor inspection event (@xstate.actor) is emitted when an actor in the system is created. It contains the following properties:

type - the type of inspection event, always '@xstate.actor'
actorRef - the reference to the actor
rootId - the session ID of the root actor of the system

Example of an actor inspection event:
{  type: '@xstate.actor',  actorRef: {/* Actor reference */},  rootId: 'x:0',}
Event inspection events​
The event inspection event (@xstate.event) is emitted when an event is sent to an actor. It contains the following properties:

type - the type of inspection event, always '@xstate.event'
actorRef - the reference to the target actor of the event
rootId - the session ID of the root actor of the system
event - the event object that was sent
sourceRef - the reference to the source actor that sent the event, or undefined if the source is not known or an event was sent directly to the actor

Example of an event inspection event:
{  type: '@xstate.event',  actorRef: {/* Actor reference */},  rootId: 'x:0',  event: {    type: 'someEvent',    message: 'hello'  },  sourceRef: {/* Actor reference */},}
Snapshot inspection events​
The snapshot inspection event (@xstate.snapshot) is emitted when an actor's snapshot is updated. It contains the following properties:

type - the type of inspection event, always '@xstate.snapshot'
actorRef - the reference to the actor
rootId - the session ID of the root actor of the system
snapshot - the most recent snapshot of the actor
event - the event that caused the snapshot to be updated

Example of a snapshot inspection event:
{  type: '@xstate.snapshot',  actorRef: {/* Actor reference */},  rootId: 'x:0',  snapshot: {    status: 'active',    context: { count: 31 },    // ...  },  event: {    type: 'increment'  }}

State machinesA state machine is a model that describes the behavior of something, for example an actor. Finite state machines describe how the state of an actor transitions to another state when an event occurs.
Read our introduction to state machines and statecharts if you haven’t already!
Benefits of state machines​
State machines help build reliable and robust software. Read more about the benefits of state machines.
Creating a state machine​
In XState, a state machine (referred to as a “machine”) is created using the createMachine(config) function:
import { createMachine } from 'xstate';const feedbackMachine = createMachine({  id: 'feedback',  initial: 'question',  states: {    question: {      on: {        'feedback.good': {          target: 'thanks',        },      },    },    thanks: {      // ...    },    // ...  },});
In this example, the machine has two states: question and thanks. The question state has a transition to the thanks state when the feedback.good event is sent to the machine:
const feedbackActor = createActor(feedbackMachine);feedbackActor.subscribe((state) => {  console.log(state.value);});feedbackActor.start();// logs 'question'feedbackActor.send({ type: 'feedback.good' });// logs 'thanks'
Creating actors from machines​
A machine contains the logic of an actor. An actor is a running instance of the machine; in other words, it is the entity whose logic is described by the machine. Multiple actors can be created from the same machine, and each of those actors will exhibit the same behavior (reaction to received events), but they will be independent of each other and have their own states.
To create an actor, use the createActor(machine) function:
import { createActor } from 'xstate';const feedbackActor = createActor(feedbackMachine);feedbackActor.subscribe((state) => {  console.log(state.value);});feedbackActor.start();// logs 'question'
You can also create an actor from other types of logic, such as functions, promises, and observables.
Providing implementations​
Machine implementations are the language-specific code that is executed but is not directly related to the state machine’s logic (states and transitions). This includes:

Actions, which are fire-and-forget side-effects.
Actors, which are entities that can communicate with the machine actor.
Guards, which are conditions that determine whether a transition should be taken.
Delays, which specify the time before a delayed transition is taken or a delayed event is sent.

The default implementations can be provided in a setup({...}) function when creating a machine, and then you can reference those implementations using JSON-serializable strings and/or objects, such as { type: 'doSomething' }.
import { setup } from 'xstate';const feedbackMachine = setup({  // Default implementations  actions: {    doSomething: () => {      console.log('Doing something!');    },  },  actors: {    /* ... */  },  guards: {    /* ... */  },  delays: {    /* ... */  },}).createMachine({  entry: { type: 'doSomething' },  // ... rest of machine config});const feedbackActor = createActor(feedbackMachine)feedbackActor.start();// logs 'Doing something!'
You can override default implementations by providing implementations via machine.provide(...). This function will create a new machine with the same config, but with the provided implementations:
const customFeedbackMachine = feedbackMachine.provide({  actions: {    doSomething: () => {      console.log('Doing something else!');    },  },});const feedbackActor = createActor(customFeedbackMachine)feedbackActor.start();// logs 'Doing something else!'
Determining the next state​
When you create a state machine actor, the next state is determined by the machine's current state and the event that is sent to the actor. If you want to determine the next state outside of the actor, you can use the getNextSnapshot(…) function:
import { getNextSnapshot } from 'xstate';import { feedbackMachine } from './feedbackMachine';const nextSnapshot = getNextSnapshot(  feedbackMachine,  feedbackMachine.resolveState({ value: 'question' }),  { type: 'feedback.good' });console.log(nextSnapshot.value);// logs 'thanks'
You can also determine the initial state of a machine using the getInitialSnapshot(…) function:
import { getInitialSnapshot } from 'xstate';import { feedbackMachine } from './feedbackMachine';const initialSnapshot = getInitialSnapshot(  feedbackMachine,  // optional input  { defaultRating: 3 });console.log(initialSnapshot.value);// logs 'question'
Specifying types​
You can specify TypeScript types inside the machine setup using the .types property:
import { setup } from 'xstate';const feedbackMachine = setup({  types: {    context: {} as { feedback: string },    events: {} as      | { type: 'feedback.good' }      | { type: 'feedback.bad' }  },  actions: {    logTelemetry: () => {      // TODO: implement    }  }}).createMachine({  // ...});
These types will be inferred throughout the machine config and in the created machine and actor so that methods such as machine.transition(...) and actor.send(...) will be type-safe.
Typegen​
Typegen does not yet support XState v5. However, with the setup(...) function and/or the .types property explained above, you can provide strong typing for most (if not all) of your machine.
Read more about setting up state machines.
API​
Coming soon…
Machines and TypeScript​
XState v5 requires TypeScript version 5.0 or greater.For best results, use the latest TypeScript version. Read more about XState and TypeScript
The best way to provide strong typing for your machine is to use the setup(...) function and/or the .types property.
import { setup, fromPromise } from 'xstate';const someAction = () => {/* ... */};const someGuard = ({ context }) => context.count <= 10;const someActor = fromPromise(async () => {  // ...  return 42;});const feedbackMachine = setup({  types: {    context: {} as { count: number },    events: {} as       | { type: 'increment' }      | { type: 'decrement' }  },  actions: {    someAction  },  guards: {    someGuard  },  actors: {    someActor  }}).createMachine({  initial: 'counting',  states: {    counting: {      entry: { type: 'someAction' }, // strongly-typed      invoke: {        src: 'someActor', // strongly-typed        onDone: {          actions: ({ event }) => {            event.output; // strongly-typed as number          }        }      },      on: {        increment: {          guard: { type: 'someGuard' }, // strongly-typed          actions: assign({            count: ({ context }) => context.count + 1          })        }      },    }  }});
Machine cheatsheet​
Use our XState machine cheatsheet below to get started quickly.
Cheatsheet: create a machine​
import { createMachine } from 'xstate';const machine = createMachine({  initial: 'start',  states: {    start: {},    // ...  },});
Cheatsheet: setup a machine with implementations​
import { setup } from 'xstate';const machine = setup({  actions: {    someAction: () => {/* ... */}  },  guards: {    someGuard: ({ context }) => context.count <= 10  },  actors: {    someActor: fromPromise(async () => {/* ... */})  },  delays: {    someDelay: () => 1000  }}).createMachine({  // ... Rest of machine config})
Cheatsheet: provide implementations​
import { createMachine } from 'xstate';import { someMachine } from './someMachine'const machineWithImpls = someMachine.provide({  actions: {    /* ... */  },  actors: {    /* ... */  },  guards: {    /* ... */  },  delays: {    /* ... */  },});

SetupIn XState version 5, you can now use the setup({ ... }) function to setup types and sources for your machines. This has many benefits:

Reduced boilerplate for strongly typing and providing named sources
More robust machine logic, as named sources are guaranteed to exist
Better type inference for actions, actors, guards, delays, context, events, etc.
Strongly-typed snapshot and done events for actors
Strongly-typed state values
Reusability of source logic

Example usage:
import { setup, assign } from 'xstate';const machine = setup({  types: {    context: {} as { count: number },    events: {} as       | { type: 'inc' }      | { type: 'dec' }  },  actions: {    increment: assign({      count: ({ context }) => context.count + 1    }),    decrement: assign({      count: ({ context }) => context.count - 1    })  }}).createMachine({  context: { count: 0 },  on: {    inc: { actions: 'increment' },    dec: { actions: 'decrement' }  }})
Ensure you are using the latest version of TypeScript (version 5.0 or higher). See the docs on TypeScript usage with XState for more information.
Setting up types​
Machine types should be setup in the types property of setup({ types }). This is where you can setup the types for your machine, including:

Types for context
Types for events, including event payloads
Types for input
Types for actions, including action params
Types for guards, including guard params
Types for actors

Migrating from createMachine​
Migrating from bare createMachine({ ... }) to setup({ ... }).createMachine({ ... }) to create a machine is simple.

Import setup instead of createMachine from 'xstate'
Move types from createMachine(...) to setup(...)
Move action, actor, guard, etc. sources from the 2nd argument of createMachine(config, sources) to setup({ ... })

import {// createMachine  setup} from 'xstate';const machine =  setup({    types: { ... },    actions: { ... },    guards: { ... }  })  .createMachine({    // types: { ... }  }, /* { actions, guards, ... } */);

StateA state describes the machine’s status or mode, which could be as simple as Paused and Playing. A state machine can only be in one state at a time.
These states are “finite”; the machine can only move through the states you’ve pre-defined.
View the Video player machine in Stately Studio.
You can visualize your state machines and easily add states in our drag-and-drop Stately editor. Read more about states in Stately’s editor.
Watch our “What are states?” video on YouTube (53s).
State object​
The state object represents the current state of a running machine (actor) and contains the following properties:

value: the current state value, which is either:

a string representing a simple state like 'playing', or:
an object representing nested states like { paused: 'buffering' }.


context: the current context (extended state.)
meta: an object containing state node meta data.

const feedbackMachine = createMachine({  id: 'feedback',  initial: 'question',  context: {    feedback: '',  },  states: {    question: {      meta: {        question: 'How was your experience?',      },    },  },});const actor = createActor(feedbackMachine);actor.start();console.log(actor.getSnapshot());// Logs an object containing:// {//   value: 'question',//   context: {//     feedback: ''//   },//   meta: {//     'feedback.question': {//       question: 'How was your experience?'//     }//   }// }
Accessing state snapshots​
You can access an actor’s emitted state (or snapshot) by subscribing to or reading from the actor’s .getSnapshot() method.
const actor = createActor(feedbackMachine);actor.subscribe((snapshot) => {  console.log(snapshot);  // logs the current snapshot state, e.g.:  // { value: 'question', ... }  // { value: 'thanks', ... }});actor.start();console.log(actor.getSnapshot());// logs { value: 'question', ... }
State value​
A state machine with nested states (or statechart) is a tree-like structure where each node is a state node. The root state node is the top-level state node that represents the entire machine. The root node may have child state nodes, which may have child state nodes, and so on.
The state value is an object that represents all the active state nodes in a machine. For state machines that have state nodes without child state nodes, the state value is a string:
Coming soon… a visual example.

state.value === 'question'
state.value === 'thanks'
state.value === 'closed'

For state machines with parent state nodes, the state value is an object:
Coming soon… a visual example.

state.value === { form: 'invalid' } - this represents a state machine with an active child node with key form that has an active child node with key invalid

For state machines with parallel state nodes, the state value contains object(s) with multiple keys for each state node region:
state.value ===  {    monitor: 'on',    mode: 'dark',  };
State machines may also have no state nodes other than the root state node. For these state machines, the state value is null.
State context​
State machines can have context, which is an object that represents the extended state of the machine. The context is immutable, and can only be updated by assigning to it in an action. You can read the state.context property to get the current context.
const currentState = feedbackActor.getSnapshot();console.log(currentState.context);// logs { feedback: '' }

Object is empty {} (default) if context is not specified in the machine config
Never mutate this object; should be treated as immutable/read-only

State children​
The state.children property represents all currently spawned/invoked actors in the current state. It is an object with keys representing the actor IDs and values representing the ActorRef instances.

This is where you access spawned/invoked actors by their ID
This is why you should give spawned/invoked actors IDs
Stopped actors will not appear here

state.can(eventType)​
The state.can(event) method determines whether an event object will cause a state change if sent to the machine actor. The method will return true if the state will change due to the event being sent; otherwise the method will return false:
const feedbackMachine = createMachine({  // ...  states: {    form: {      // ...      on: {        'feedback.submit': {          guard: 'isValid',          target: 'thanks',        },      },    },  },});const feedbackActor = createActor(feedbackMachine).start();// ...const currentState = feedbackActor.getSnapshot();console.log(currentState.can({ type: 'feedback.submit' }));// logs `true` if the 'feedback.submit' event will cause a transition, which will occur if:// - the current state is 'form'// - the 'isValid' guard evaluates to `true`
A state is considered “changed” if a transition is enabled for the given state and event object.
The state.can(...) method will also check transition guards by executing them. Transition guards should be pure functions.
state.hasTag(tag)​
The state.hasTag(tag) method determines whether any state nodes in the current state value have the given tag. This is useful for determining whether a state is a particular state, or whether a state is a member of a particular state group.
const feedbackMachine = createMachine({  // ...  states: {    submitting: {      tags: ['loading'],      // ...    },  },});const feedbackActor = createActor(feedbackMachine).start();const currentState = feedbackActor.getSnapshot();const showLoadingSpinner = currentState.hasTag('loading');
Prefer using state.hasTag(tag) over state.matches(stateValue), as state.hasTag(tag) is more resilient to changes in the machine.
state.matches(stateValue)​
The state.matches(stateValue) method determines whether the current state.value matches the given stateValue. If the current state.value is a "subset" of the provided stateValue, then the method will return true.
// state.value === 'question'state.matches('question'); // true// state.value === { form: 'invalid' }state.matches('form'); // truestate.matches('question'); // falsestate.matches({ form: 'invalid' }); // truestate.matches({ form: 'valid' }); // false
state.output​
The state.output property represents the output data of a state machine when it is in its top-level final state; i.e., state.status === 'done'.
const state = actor.getSnapshot();if (state.status === 'done') {  console.log(state.output);}
state.getMeta()​
The state.getMeta() method represents the metadata of all the state nodes in the state. It is an object with keys that represent the state node IDs, and values that are the metadata of that state node.
const feedbackMachine = createMachine({  id: 'feedback',  // ...  states: {    form: {      meta: {        view: 'shortForm',      }    }  }});const feedbackActor = createActor(feedbackMachine).start();// Assume the current state is 'form'const currentState = feedbackActor.getSnapshot();console.log(currentState.getMeta());// logs { 'feedback.form': { view:'shortForm' } }
State descriptions​
You can add .description to states to describe their purpose and share related notes with your team. In Stately Studio’s editor, these descriptions are rendered in the machine and support markdown including links, images, and lists. Read more about descriptions in Stately Studio.
states: {  "Loading Move Destinations": {    description:      "Load data from the server based on the entity's id and type (project or machine). Result includes the entity's current location, and the list or tree of valid destination options to which the user may move that entity.",    invoke: {      src: "loadMoveData",      id: "loadMoveData",      onDone: [        {          target: "Destination Menu",          actions: "setDestinations",        },      ],      onError: [        {          target: "Data Loading Error",        },      ],    },  },}
States and TypeScript​
XState v5 requires TypeScript version 5.0 or greater.For best results, use the latest TypeScript version. Read more about XState and TypeScript
Coming soon
States cheatsheet​
Cheatsheet: read or match a state value​
const state = actor.getSnapshot();const currentStateValue = state.value;const isLoading = state.matches('loading');
Cheatsheet: read state context​
console.log(state.context);
Cheatsheet: read state output​
if (state.status === 'done') {  // Output may exist  console.log(state.output);} else {  // Output does not exist  state.output === undefined;}
Cheatsheet: read state meta data​
console.log(state.getMeta());
Further resources​
Persisting state

ContextIn XState, context is how you store data in a state machine actor.
The context property is available in all states and used to store data relevant to an actor. The context object is immutable, so you cannot directly modify it. Instead, for state machine logic, you can use the assign(...) action to update context.
The context property is optional; if the state machine only specifies finite states and no external contextual data, it may not need context.
import { createMachine } from 'xstate';const feedbackMachine = createMachine({  // Initialize the state machine with context  context: {    feedback: 'Some feedback',  },});const feedbackActor = createActor(feedbackMachine);feedbackActor.subscribe((state) => {  console.log(state.context.feedback);});feedbackActor.start();// logs 'Some feedback'
Initial context​
Set the initial context of a machine in the context property of the machine config:
import { createMachine } from 'xstate';const feedbackMachine = createMachine({  context: {    feedback: 'Some feedback',    rating: 5,    // other properties  },});
The object you pass to context will be the initial context value for any actor created from this machine.
Do not mutate the context object. Instead, you should use the assign(...) action to update context immutably. If you mutate the context object, you may get unexpected behavior, such as mutating the context of other actors.
Lazy initial context​
Context can be initialized lazily by passing a function that returns the initial context value:
const feedbackMachine = createMachine({  context: () => ({    feedback: 'Some feedback',    createdAt: Date.now(),  }),});const feedbackActor = createActor(feedbackMachine).start();console.log(feedbackActor.getSnapshot().context.createdAt);// logs the current timestamp
Lazy initial context is evaluated per actor, so each actor will have its own context object.
Input​
You can provide input data to a machine’s initial context by passing an input property to the createActor(machine, { input }) function and using the input property from the first argument in the context function:
import { setup } from 'xstate';const feedbackMachine = setup({  types: {    context: {} as {      feedback: string;      rating: number;    },    input: {} as {      defaultRating: number    }  }}).createMachine({  context: ({ input }) => ({    feedback: '',    rating: input.defaultRating,  }),});const feedbackActor = createActor(feedbackMachine, {  input: {    defaultRating: 5,  },}).start();console.log(feedbackActor.getSnapshot().context.rating);// logs 5
Learn more about input.
Updating context with assign(...)​
Use the assign(...) action in a transition to update context:
import { createMachine, assign } from 'xstate';const feedbackMachine = createMachine({  context: {    feedback: 'Some feedback',  },  on: {    'feedback.update': {      actions: assign({        feedback: ({ event }) => event.feedback,      }),    },  },});const feedbackActor = createActor(feedbackMachine);feedbackActor.subscribe((state) => {  console.log(state.context.feedback);});feedbackActor.start();// logs 'Some feedback'feedbackActor.send({  type: 'feedback.update',  feedback: 'Some other feedback',});// logs 'Some other feedback'
Context and TypeScript​
XState v5 requires TypeScript version 5.0 or greater.For best results, use the latest TypeScript version. Read more about XState and TypeScript
You can strongly type the context of your machine in the types.context property of the actor setup..
import { setup } from 'xstate';const machine = setup({  types: {} as {    context: {      feedback: string;      rating: number;    };  }}).createMachine({  // Initial context  context: {    feedback: '',    rating: 5,  },  entry: ({ context }) => {    context.feedback; // string    context.rating; // number  },});
Context cheatsheet​
Use our XState context cheatsheet below to get started quickly.
Cheatsheet: initial context​
const machine = createMachine({  context: {    feedback: '',  },});
Cheatsheet: lazy initial context​
const machine = createMachine({  context: () => ({    feedback: '',    createdAt: Date.now(),  }),});
Cheatsheet: updating context with assign(...)​
const machine = createMachine({  context: {    feedback: '',  },  on: {    'feedback.update': {      actions: assign({        feedback: ({ event }) => event.feedback,      }),    },  },});
Cheatsheet: input​
import { setup } from 'xstate';const feedbackMachine = setup({  types: {    context: {} as {      feedback: string;      rating: number;    },    input: {} as {      defaultRating: number    }  }}).createMachine({  context: ({ input }) => ({    feedback: '',    rating: input.defaultRating,  }),});const feedbackActor = createActor(feedbackMachine, {  input: {    defaultRating: 5,  },}).start();

InputInput refers to the data provided to a state machine that influences its behavior. In XState, you provide input when creating an actor using the second argument of the createActor(machine, { input }) function:
import { createActor, setup } from 'xstate';const feedbackMachine = setup({  types: {    context: {} as {      userId: string;      feedback: string;      rating: number;    },    input: {} as {      userId: string;      defaultRating: number;    }  }}).createMachine({  context: ({ input }) => ({    userId: input.userId,    feedback: '',    rating: input.defaultRating,  }),  // ...});const feedbackActor = createActor(feedbackMachine, {  input: {    userId: '123',    defaultRating: 5,  },});
Input is coming to Stately Studio’s editor soon.
Creating actors with input​
You can pass input to any kind of actor by reading this input from the input property of the first argument to actor logic creators, such as fromPromise(), fromTransition(), fromObservable(), and other actor logic creators.
Input with fromPromise():
import { createActor, fromPromise } from 'xstate';const userFetcher = fromPromise(({ input }: { input: { userId: string } }) => {  return fetch(`/users/${input.userId}`).then((res) => res.json());});const userFetcherActor = createActor(userFetcher, {  input: {    userId: '123',  },}).start();userFetcherActor.onDone((data) => {  console.log(data);  // logs the user data for userId 123});
Input with fromTransition():
import { createActor, fromTransition } from 'xstate';const counter = fromTransition((state, event)) => {  if (event.type === 'INCREMENT') {    return { count: state.count + 1 };  }  return state;}, ({ input }: { input: { startingCount?: number } }) => ({  count: input.startingCount ?? 0,});const counterActor = createActor(counter, {  input: {    startingCount: 10,  }});
Input with fromObservable():
import { createActor, fromObservable } from 'xstate';import { interval } from 'rxjs';const intervalLogic = fromObservable(({ input }: { input: { interval: number } }) => {  return interval(input.interval);});const intervalActor = createActor(intervalLogic, {  input: {    interval: 1000,  },})intervalActor.start();
Initial event input​
When an actor is started, it will automatically send a special event named xstate.init to itself. If input is provided to the createActor(logic, { input }) function, it will be included in the xstate.init event:
import { createActor, createMachine } from 'xstate';const feedbackMachine = createMachine({  entry: ({ event }) => {    console.log(event.input);    // logs { userId: '123', defaultRating: 5 }  },  // ...});const feedbackActor = createActor(feedbackMachine, {  input: {    userId: '123',    defaultRating: 5,  },}).start();
Invoking actors with input​
You can provide input to invoked actors via the input property of the invoke configuration:
import { createActor, setup } from 'xstate';const feedbackMachine = setup({  actors: {    liveFeedback: fromPromise(({ input }: { input: { domain: string } }) => {      return fetch(`https://${input.domain}/feedback`).then((res) =>        res.json(),      );    }),  }}).createMachine({  invoke: {    src: 'liveFeedback',    input: {      domain: 'stately.ai',    },  },});
The invoke.input property can be a static input value or a function that returns the input value. The function will be called with an object that contains the current context and event:
import { createActor, setup } from 'xstate';const feedbackMachine = setup({  actors: {    fetchUser: fromPromise(({ input }) => {      return fetch(`/users/${input.userId}`).then((res) => res.json());    }),  },}).createMachine({  context: {    userId: '',    feedback: '',    rating: 0,  },  invoke: {    src: 'fetchUser',    input: ({ context }) => ({ userId: context.userId }),  },  // ...});
Spawning actors with input​
You can provide input to spawned actors via the input property of the spawn configuration:
import { createActor, setup, type AnyActorRef } from 'xstate';const feedbackMachine = setup({  types: {    context: {} as {      userId: string;      feedback: string;      rating: number;      emailRef: AnyActorRef;    }  },  actors: {    emailUser: fromPromise(({ input }: { input: { userId: string } }) => {      return fetch(`/users/${input.userId}`, {        method: 'POST',        // ...      });    }),  },}).createMachine({  context: {    userId: '',    feedback: '',    rating: 0,    emailRef: null,  },  // ...  on: {    'feedback.submit': {      actions: assign({        emailRef: ({ context, spawn }) => {          return spawn('emailUser', {            input: { userId: context.userId },          });        },      }),    },  },  // ...});
Use-cases​
Input is useful for creating reusable machines that can be configured with different input values.

Replaces the old way of writing a factory function for machines:

// Old way: using a factory functionconst createFeedbackMachine = (userId, defaultRating) => {  return createMachine({    context: {      userId,      feedback: '',      rating: defaultRating,    },    // ...  });};const feedbackMachine1 = createFeedbackMachine('123', 5);const feedbackActor1 = createActor(feedbackMachine1).start();// New way: using inputconst feedbackMachine = createMachine({  context: ({ input }) => ({    userId: input.userId,    feedback: '',    rating: input.defaultRating,  }),  // ...});const feedbackActor = createActor(feedbackMachine, {  input: {    userId: '123',    defaultRating: 5,  },});
Passing new data to an actor​
Changing the input will not cause the actor to be restarted. You need to send an event to the actor to pass the new data to the actor:
const Component = (props) => {  const feedbackActor = useActor(feedbackMachine, {    input: {      userId: props.userId,      defaultRating: props.defaultRating,    },  });  useEffect(() => {    feedbackActor.send({      type: 'userId.change',      userId: props.userId,    });  }, [props.userId]);  // ...};
Input and TypeScript​
XState v5 requires TypeScript version 5.0 or greater.For best results, use the latest TypeScript version. Read more about XState and TypeScript
You can strongly type the input of your machine in the types.input property of the machine setup.
import { createActor, setup } from 'xstate';const machine = setup({  types: {    input: {} as {      userId: string;      defaultRating: number;    };    context: {} as {      userId: string;      feedback: string;      rating: number;    };  },}).createMachine({  context: ({ input }) => ({    userId: input.userId,    feedback: '',    rating: input.defaultRating,  }),});const actor = createActor(machine, {  input: {    userId: '123',    defaultRating: 5,  },});
Input cheatsheet​
Use our XState input cheatsheet below to get started quickly.
Cheatsheet: providing input​
const feedbackActor = createActor(feedbackMachine, {  input: {    userId: '123',    defaultRating: 5,  },});
Cheatsheet: providing input to invoked actors​
const feedbackMachine = createMachine({  invoke: {    src: 'liveFeedback',    input: {      domain: 'stately.ai',    },  },});
Cheatsheet: providing dynamic input to invoked actors​
const feedbackMachine = createMachine({  context: {    userId: 'some-user-id',  },  invoke: {    src: 'fetchUser',    input: ({ context }) => ({ userId: context.userId }),  },});
Cheatsheet: providing input to spawned actors​
const feedbackMachine = createMachine({  context: {    userId: '',  },  // ...  on: {    'feedback.submit': {      actions: assign({        emailRef: ({ context, spawn }) => {          return spawn('emailUser', {            input: { userId: context.userId },          });        },      }),    },  },  // ...});

OutputOutput refers to the final data that an actor produces. When an actor is responsible for performing some task, such as making a network request or running complex calculations, it will return output once it finishes that task. The output represents the result of the actor’s work. Actors only produce output when their status is “done”; i.e. when they are in their final state.
Some actors may run indefinitely and not produce any output.
Output in machine actors​
Read final states for more information on how to specify output in machine actors.
Output in promise actors​
When a promise actor resolves, it can produce output data. You can specify this output data in the .output property of the machine:
import { fromPromise, createActor } from 'xstate';const promiseLogic = fromPromise(async () => {  const response = await fetch('https://example.com');  return response.json() as { message: string };});const actor = createActor(promiseLogic);actor.subscribe(snapshot => {  if (snapshot.status === 'done') {    console.log(snapshot.output.message);  }});actor.start();
Output and TypeScript​
XState v5 requires TypeScript version 5.0 or greater.For best results, use the latest TypeScript version. Read more about XState and TypeScript
The output property can be typed in the .types property of the machine setup:
import { setup, createActor } from 'xstate';const machine = setup({  types: {    output: {} as { total: number }  }}).createMachine({  // ...  output: ({ context }) => ({    total: context.items.reduce((total, item) => total + item.price, 0),  })});const actor = createActor(machine);actor.subscribe(snapshot => {  if (snapshot.status === 'done') {    console.log(snapshot.output.total);  }});
You can read the output type from any actor using OutputFrom<typeof actor>:
import type { OutputFrom } from 'xstate';import { machine } from './machine';const actor = createActor(machine);function acceptOutput<T>(output: OutputFrom<typeof actor>) {  console.log(output.total);}

Events and transitionsA transition is a change from one finite state to another, triggered by an event.
An event is a signal, trigger, or message that causes a transition. When an actor receives an event, its machine will determine if there are any enabled transitions for that event in the current state. If enabled transitions exist, the machine will take them and execute their actions.
You can visualize your state machines and easily add transitions in our drag-and-drop Stately editor. Read more about transitions in Stately’s editor.
<a href="https://stately.ai/registry/editor/embed/e13bef2b-bb13-4465-96ac-0bc25340688e?machineId=9630e3b7-9f8e-4dc9-8b55-661f854d28b7&amp;mode=Simulate">View the <em>Video player</em> machine in Stately Studio</a>.
Transitions are “deterministic”; each combination of state and event always points to the same next state. When a state machine receives an event, only the active finite states are checked to see if any of them have a transition for that event. Those transitions are called enabled transitions. If there is an enabled transition, the state machine will execute the transition's actions, and then transition to the target state.
Transitions are represented by on: in a state:
import { createMachine } from 'xstate';const feedbackMachine = createMachine({  id: 'feedback',  initial: 'question',  states: {    question: {      on: {        'feedback.good': {          target: 'thanks'        }      }    },    thanks: {}  },});
Event objects​
In XState, events are represented by event objects with a type property and optional payload:

The type property is a string that represents the event type.
The payload is an object that contains additional data about the event.

feedbackActor.send({  // The event type  type: 'feedback.update',  // Additional payload  feedback: 'This is great!',  rating: 5,});
Selecting transitions​
Transitions are selected by checking the deepest child states first. If the transition is enabled (i.e. if its guard passes), it will be taken. If not, the parent state will be checked, and so on.

Start on the deepest active state nodes (aka atomic state nodes)
If the transition is enabled (no guard or its guard evaluates to true), select it.
If no transition is enabled, go up to the parent state node and repeat step 1.
Finally, if no transitions are enabled, no transitions will be taken, and the state will not change.

Self-transitions​
A state can transition to itself. This is known as a self-transition, and is useful for changing context and/or executing actions without changing the finite state. You can also use self-transitions to restart a state.
Root self-transitions:
import { createMachine, assign } from 'xstate';const machine = createMachine({  context: { count: 0 },  on: {    someEvent: {      // No target      actions: assign({        count: ({context}) => context.count + 1,      })    }  }});
<a href="https://stately.ai/registry/editor/embed/c447d996-cef1-421d-a422-8be695668764?mode=design&amp;machineId=91da1d57-b146-48fd-82ce-a9dd28b7261a">View the <em></em> machine in Stately Studio</a>.
Self-transitions on states:
import { createMachine, assign } from 'xstate';const machine = createMachine({  context: { count: 0 },  initial: 'inactive',  states: {    inactive: {      on: { activate: { target: 'active' } }    },    active: {      on: {        someEvent: {          // No target          actions: assign({            count: ({context}) => context.count + 1,          })        }      }    }  }});
<a href="https://stately.ai/registry/editor/embed/c447d996-cef1-421d-a422-8be695668764?mode=design&amp;machineId=8763e570-3535-42b3-a2a2-8edd82d1207a">View the <em></em> machine in Stately Studio</a>.
You can easily visualize self-transitions in Stately’s editor. Read more about self-transitions in Stately’s editor.
Transitions between states​
Usually, transitions are between two sibling states. These transitions are defined by setting the target as the sibling state key.
const feedbackMachine = createMachine({  // ...  states: {    form: {      on: {        submit: {          // Target is the key of the sibling state          target: 'submitting',        },      },    },    submitting: {      // ...    },  },});
Parent to child transitions​
When a state machine actor receives an event, it will first check the deepest (atomic) state to see if there is any enabled transition. If not, the parent state is checked, and so on, until the state machine reaches the root state.
When you want an event to transition to a state regardless of which sibling state is active, a useful pattern is to transition from the parent state to the child state.
For example, the below state machine will transition to the colorMode.system state on the mode.reset event regardless of which state it is currently in.
import { createMachine } from 'xstate';const machine = createMachine({  id: 'colorMode',  initial: 'system',  states: {    system: {},    auto: {},    light: {      on: {        'mode.toggle': { target: 'dark' }      }    },    dark: {      on: {        'mode.toggle': { target: 'light' }      }    }  },  on: {    'mode.reset': {      target: '.system'    }  }});
Re-entering​
By default, when a state machine transitions from some state to the same state or from a parent state to a descendent (child, grandchild, etc.) of that parent state, it will not re-enter the state; that is, it will not execute the exit and entry actions of the parent state. It will not stop existing invoked actors or start new invoked actors.
This can be changed with the transition reenter property: if you want the parent state to be re-entered, you can set reenter: true. This will cause the state to re-enter when transitioning to itself or descendent states, executing the exit and entry actions of the state. It will stop existing invoked actors, and start new invoked actors.
In XState v4, re-entering transitions were known as external transitions, and the default transitions were known as internal transitions.
Self-transitions with reenter: true:
import { createMachine } from 'xstate';const machine = createMachine({  initial: 'someState',  states: {    someState: {      entry: () => console.log('someState entered'),      exit: () => console.log('someState exited'),      on: {        'event.normal': {          target: 'someState', // or no target        },        'event.thatReenters': {          target: 'someState', // or no target          reenter: true,        }      }    }  }});const actor = createActor(machine);actor.start();actor.send({ type: 'event.normal' });// Does not log anythingactor.send({ type: 'event.thatReenters' });// Logs:// "someState exited"// "someState entered"
Parent-child (or descendent) transitions with reenter: true:
const machine = createMachine({  initial: 'parentState',  states: {    parentState: {      entry: () => console.log('parentState entered'),      exit: () => console.log('parentState exited'),      on: {        'event.normal': {          target: '.someChildState'        },        'event.thatReenters': {          target: '.otherChildState',          reenter: true        }      },      initial: 'someChildState',      states: {        someChildState: {          entry: () => console.log('someChildState entered'),          exit: () => console.log('someChildState exited')        },        otherChildState: {          entry: () => console.log('otherChildState entered'),          exit: () => console.log('otherChildState exited')        }      }    }  }});const actor1 = createActor(machine);actor1.start();actor1.send({ type: 'event.normal' });// Logs:// "someChildState exited"// "someChildState entered"const actor2 = createActor(machine);actor2.start();console.log('---');actor2.send({ type: 'event.thatReenters' });// Logs:// "someChildState exited"// "parentState exited"// "parentState entered"// "otherChildState entered"
Transitions to any state​
Sibling descendent states: { target: 'sibling.child.grandchild' }
Parent to descendent states: { target: '.child.grandchild' }
State to any state: { target: '#specificState' }
Forbidden transitions​

{ on: { forbidden: {} } }
Different than omitting the transition; transition selection algorithm will stop looking
Same as { on: { forbidden: { target: undefined } } }

Wildcard transitions​
A wildcard transition is a transition that will match any event. The event descriptor (key of the on: {...} object) is defined using the * wildcard character as the event type:
import { createMachine } from 'xstate';const feedbackMachine = createMachine({  initial: 'asleep',  states: {    asleep: {      on: {        // This transition will match any event        '*': { target: 'awake' },      },    },    awake: {},  },});
Wildcard transitions are useful for:

handling events that are not handled by any other transition.
as a “catch-all” transition that handles any event in a state.

A wildcard transition has the least priority; it will only be taken if no other transitions are enabled.
Partial wildcard transitions​
A partial wildcard transition is a transition that matches any event that starts with a specific prefix. The event descriptor is defined by using the wildcard character (*) after a dot (.) as the event type:
import { createMachine } from 'xstate';const feedbackMachine = createMachine({  initial: 'prompt',  states: {    prompt: {      on: {        // This will match the 'feedback' event as well as        // any event that starts with 'feedback.', e.g.:        // 'feedback.good', 'feedback.bad', etc.        'feedback.*': { target: 'form' },      },    },    form: {},    // ...  },});
The wildcard character (*) can only be used in the suffix of an event descriptor, following a dot (.):
Valid wildcard examples​

✅ mouse.*: matches mouse, mouse.click, mouse.move, etc.
✅ mouse.click.*: matches mouse.click, mouse.click.left, mouse.click.right, etc.

Invalid wildcard​

🚫 mouse*: invalid; does not match any event.
🚫 mouse.*.click: invalid; * cannot be used in the middle of an event descriptor.
🚫 *.click: invalid; * cannot be used in the prefix of an event descriptor.
🚫 mouse.click*: invalid; does not match any event.
🚫 mouse.*.*: invalid; * cannot be used in the middle of an event descriptor.

Multiple transitions in parallel states​
Since parallel states have multiple regions that can be active at the same time, it is possible for multiple transitions to be enabled at the same time. In this case, all enabled transitions to these regions will be taken.
Multiple targets are specified as an array of strings:
Coming soon… example.
Other transitions​

Eventless (always) transitions are transitions without events. These transitions are always taken after any transition in their state is enabled.
Delayed (after) transitions are transitions that are enabled after a specified duration.

Transition descriptions​
You can add a .description string to a transition to describe the transition. This is useful for explaining the purpose of the transition in the visualized state machine.
import { createMachine } from 'xstate';const feedbackMachine = createMachine({  // ...  on: {    exit: {      description: 'Closes the feedback form',      target: '.closed',    },  },});
Shorthands​
If the transition only specifies a target, then the string target can be used as a shorthand instead of the entire transition object:
import { createMachine } from 'xstate';const feedbackMachine = createMachine({  initial: 'prompt',  states: {    prompt: {      on: {        // This is shorthand for:        // 'feedback': { target: 'form' }        'feedback.good': 'thanks',      },    },    thanks: {},    // ...  },});
Using the string target shorthand is useful for quickly prototyping state machines. Generally, we recommended using the full transition object syntax as it will be consistent with all other transition objects and will be easier to add actions, guards, and other properties to the transition in the future.
TypeScript​
XState v5 requires TypeScript version 5.0 or greater.For best results, use the latest TypeScript version. Read more about XState and TypeScript
Transitions mainly use the event type that they are enabled by.
import { setup } from 'xstate';const machine = setup({  types: {    events: {} as      | { type: 'greet'; message: string }      | { type: 'submit' }  }}).createMachine({  // ...  on: {    greet: {      actions: ({ event }) => {        event.type; // 'greet'        event.message; // string      },    },  },});
Frequently asked questions​
How can I listen for events sent to actors?You can use the inspection API to listen for all inspection events in an actor system. The @xstate.event inspection event contains information about events sent from one actor to another (or itself):import { createActor } from 'xstate';import { someMachine } from './someMachine';const actor = createActor(someMachine, {  inspect: (inspectionEvent) => {    if (inspectionEvent.type === '@xstate.event') {      // The event object sent from one actor to another      console.log(inspectionEvent.event);    }  }});
Transitions cheatsheet​
Use our XState events and transitions cheatsheet below to get started quickly.
Cheatsheet: event objects​
feedbackActor.send({  // Event type  type: 'feedback.update',  // Event payload  feedback: 'A+ would use state machines again',  rating: 5,});
Cheatsheet: transition targets​
const machine = createMachine({  initial: 'a',  states: {    a: {      on: {        // Sibling target        event: {          target: 'b',        },        // Sibling child target        otherEvent: {          target: 'b.c',        },      },    },    b: {      on: {        // ID target        event: {          target: '#c',        },      },    },    c: {      id: 'c',      on: {        // Child target        event: {          target: '.child',        },      },      initial: 'child',      states: {        child: {},      },    },  },  on: {    // Child target    someEvent: {      target: '.b',    },  },});

Eventless (always) transitionsEventless transitions are transitions that happen without an explicit event. These transitions are always taken when the transition is enabled.
Eventless transitions are specified on the always state property and often referred to as “always” transitions.
You can easily visualize and simulated eventless transitions in Stately’s editor. Read more about eventless transitions in Stately’s editor.
import { createMachine } from 'xstate';const machine = createMachine({  states: {    form: {      initial: 'valid',      states: {        valid: {},        invalid: {}      },      always: {        guard: 'isValid',        target: 'valid',      }    }  }});
Eventless transitions and guards​
Eventless transitions are taken immediately after normal transitions are taken. They are only taken if enabled, for example, if their guards are true. This makes eventless transitions helpful in doing things when some condition is true.
Avoid infinite loops​
Since unguarded “always” transitions always run, you should be careful not to create an infinite loop. XState will help guard against most infinite loop scenarios.
Eventless transitions with no target nor guard will cause an infinite loop. Transitions using guard and actions may run into an infinite loop if its guard keeps returning true.
You should define eventless transitions either with:

target
guard + target
guard + actions
guard + target + actions

If target is declared, the value should differ from the current state node.
When to use​
Eventless transitions can be helpful when a state change is necessary, but there is no specific trigger for that change.
import { createMachine } from 'xstate';const machine = createMachine({  id: 'kettle',  initial: 'lukewarm',  context: {    temperature: 80,  },  states: {    lukewarm: {      on: {        boil: { target: 'heating' }      }    },    heating: {      always: {        guard: ({ context }) => context.temperature > 100,        target: 'boiling'      }    },    boiling: {      entry: ['turnOffLight'],      always: {        guard: ({ context }) => context.temperature <= 100,        target: 'heating'      }    }  },  on: {    'temp.update': {      actions: ['updateTemperature'],    }  },});
View the  machine in Stately Studio.
Eventless transitions and TypeScript​
XState v5 requires TypeScript version 5.0 or greater.For best results, use the latest TypeScript version. Read more about XState and TypeScript
Eventless transitions can potentially be enabled by any event, so the event type is the union of all possible events.
const machine = createMachine({  types: {} as {    events:      | { type: 'greet'; message: string }      | { type: 'submit' };  },  // ...  always: {    actions: ({ event }) => {      event.type; // 'greet' | 'submit'    },    guard: ({ event }) => {      event.type; // 'greet' | 'submit'      return true;    },  },});
Eventless transitions cheatsheet​
Cheatsheet: root eventless (always) transition​
import { createMachine } from 'xstate';const machine = createMachine({  always: {    guard: 'isValid',    actions: ['doSomething'],  },  // ...});
Cheatsheet: state eventless (always) transition​
const machine = createMachine({  initial: 'start',  states: {    start: {      always: {        guard: 'isValid',        target: 'otherState',      },    },    otherState: {/* ... */}  }});

Delayed (after) transitionsDelayed transitions are transitions that are triggered after a set amount of time. Delayed transitions are useful for building timeouts and intervals into your application logic. If another event occurs before the end of the timer, the transition doesn’t complete.
Delayed transitions are defined on the after property of a state node, either as a number (measured in milliseconds) or as a string that references a delay defined in the delays setup object.
You can easily visualize and simulate delayed transitions in Stately’s editor. Read more about delayed transitions in Stately’s editor.
import { createMachine } from 'xstate';const pushTheButtonGame = createMachine({  initial: 'waitingForButtonPush',  states: {    waitingForButtonPush: {      after: {        5000: {          target: 'timedOut',          actions: 'logThatYouGotTimedOut',        },      },      on: {        PUSH_BUTTON: {          actions: 'logSuccess',          target: 'success',        },      },    },    success: {},    timedOut: {},  },});
<a href="https://stately.ai/registry/editor/embed/c447d996-cef1-421d-a422-8be695668764?mode=design&amp;machineId=78c59862-fc40-4b1e-8f9c-42f1b2ddc410">View the <em></em> machine in Stately Studio</a>.
Watch our “Delayed (after) transitions” video on YouTube (1m17s).
Delays​
You can define delays in a few ways: inlined, referenced, and as an expression.
Inlined delays​
You can define an inlined delay by specifying the delay time (in milliseconds) directly:
const machine = createMachine({  initial: 'idle',  states: {    idle: {      after: {        1000: { target: 'nextState' },      },    },    nextState: {},  },});
This will transition to the nextState state after 1000ms.
Referenced delays​
You can also define referenced delays by specifying a string delay key, and providing the actual delay time separately.
For example:
import { setup } from 'xstate';const machine = setup({  delays: {    timeout: 1000,  },}).createMachine(  {    initial: 'idle',    states: {      idle: {        after: {          timeout: { target: 'nextState' },        },      },      nextState: {},    },  });
Dynamic delays​
Delays can also be dynamically defined as a function that returns the delay time in milliseconds:
import { setup } from 'xstate';const machine = setup({  types: {    context: {} as {      attempts: number    }  },  delays: {    timeout: ({ context }) => {      return context.attempts * 1000;    },  },}).createMachine({  initial: 'attempting',  states: {    attempting: {      after: {        timeout: {          actions: assign({ attempts: (context) => context.attempts + 1 }),          target: 'attempting',        },      },    },    // ...  },});
Lifecycle​
Delayed transition timers are canceled when the state is exited.
Testing​

Simulated clock

Delayed transitions and TypeScript​
XState v5 requires TypeScript version 5.0 or greater.For best results, use the latest TypeScript version. Read more about XState and TypeScript
You can strongly type the delays of your machine by setting up the the delays in the setup() function:
import { setup } from 'xstate';const machine = setup({  delays: {    shortTimeout: 1000,    longTimeout: 5000,    eventually: 10_000  }}).createMachine({  after: {    shortTimeout: {/* ... */}  }});
Delayed transitions cheatsheet​
Use our XState delayed transitions cheatsheet below to get started quickly.
createMachine({  after: {    DELAY: {      /* ... */    },  },}).provide({  delays: {    DELAY: 1000, // or expression  },});

ActionsActions are fire-and-forget effects. When a state machine transitions, it may execute actions. Actions occur in response to events, and are typically defined on transitions in the actions: [...] property. Actions can also be defined for any transition that enters a state in the state's entry: [...] property, or for any transition that exits a state in the state's exit: [...] property.
You can visualize your state machines and easily add actions in our drag-and-drop Stately editor. Read more about actions in Stately’s editor.
Actions can also be on a state’s entry or exit, also as a single action or an array.
import { setup } from 'xstate';const feedbackMachine = setup({  actions: {    track: (_, params: unknown) => {      track(params);      // Tracks { response: 'good' }    },    showConfetti: () => {      // ...    }  }}).createMachine({  // ...  states: {    // ...    question: {      on: {        'feedback.good': {          actions: [            { type: 'track', params: { response: 'good' } }          ]        }      },      exit: [        { type: 'exitAction' }      ]    }    thanks: {      entry: [        { type: 'showConfetti' }      ],    }  }});
Examples of actions:

Logging a message
Sending a message to another actor
Updating context

Entry and exit actions​
Entry actions are actions that occur on any transition that enters a state node. Exit actions are actions that occur on any transition that exits a state node.
Entry and exit actions are defined using the entry: [...] and exit: [...] attributes on a state node. You can fire multiple entry and exit actions on a state. Top-level final states cannot have exit actions, since the machine is stopped and no further transitions can occur.
View the  machine in Stately Studio.
Action objects​
Action objects have an action type and an optional params object:

The action type property describes the action. Actions with the same type have the same implementation.
The action params property hold parameterized values that are relevant to the action.

import { setup } from 'xstate';const feedbackMachine = setup({  actions: {    track: (_, params: unknown) => {/* ... */}  }}).createMachine({  // ...  states: {    // ...    question: {      on: {        'feedback.good': {          actions: [            {              // Action type              type: 'track',              // Action params              params: { response: 'good' },            },          ],        },      },    },  },});
Dynamic action parameters​
You can dynamically pass parameters in the params property to action objects by using a function that returns the params. The function takes in an object that contains the current context and event as arguments.
import { setup } from 'xstate';const feedbackMachine = setup({  actions: {    logInitialRating: (_, params: { initialRating: number }) => {      // ...    }  }}).createMachine({  context: {    initialRating: 3  },  entry: [{    type: 'logInitialRating',    params: ({ context }) => ({      initialRating: context.initialRating    })  }]});
This is a recommended approach for making actions more reusable, since you can define actions that do not rely on the machine’s context or event types.
import { setup } from 'xstate';function logInitialRating(_, params: { initialRating: number }) {  console.log(`Initial rating: ${params.initialRating}`);}const feedbackMachine = setup({  actions: { logInitialRating }}).createMachine({  context: { initialRating: 3 },  entry: [{    type: 'logInitialRating',    params: ({ context }) => ({      initialRating: context.initialRating    })  }]});
Inline actions​
You can declare actions as inline functions:
import { createMachine } from 'xstate';const feedbackMachine = createMachine({  entry: [    // Inline action    ({ context, event }) => {      console.log(/* ... */);    },  ],});
Inline actions are useful for prototyping and simple cases but we generally recommended using action objects.
Implementing actions​
You can setup the implementations for named actions in the actions property of the setup(...) function
import { setup } from 'xstate';const feedbackMachine = setup({  actions: {    track: ({ context, event }, params) => {      // Action implementation      // ...    },  }}).createMachine(  {    // Machine config    entry: [{ type: 'track', params: { msg: 'entered' }}]  },);
You can also provide action implementations to override existing actions in the machine.provide(...) method, which creates a new machine with the same config but with the provided implementations:
const feedbackActor = createActor(  feedbackMachine.provide({    actions: {      track: ({ context, event }, params) => {        // Different action implementation        // (overrides previous implementation)        // ...      },    },  }),);
Built-in actions​
XState provides a number of useful built-in actions that are a core part of the logic of your state machines, and not merely side-effects.
Built-in actions, such as assign(…), sendTo(…), and raise(…), are not imperative; they return a special action object (e.g. { type: 'xstate.assign', … }) that are interpreted by the state machine. Do not call built-in action in custom action functions.// ❌ This will have no effectconst machine = createMachine({  context: { count: 0 },  entry: ({ context }) => {    // This action creator only returns an action object    // like { type: 'xstate.assign', ... }    assign({ count: context.count + 1 });  }});// ✅ This will work as expectedconst machine = createMachine({  context: { count: 0 },  entry: assign({    count: ({ context }) => context.count + 1  })});// ✅ Imperative built-in actions are available in `enqueueActions(…)`const machine = createMachine({  context: { count: 0 },  entry: enqueueActions(({ context, enqueue }) => {    enqueue.assign({      count: context.count + 1    });  })});
Assign action​
The assign(...) action is a special action that assigns data to the state context. The assignments argument in assign(assignments) is where assignments to context are specified.
Assignments can be an object of key-value pairs where the keys are context keys and the values are either static values or expressions that return the new value:
import { setup } from 'xstate';const countMachine = setup({  types: {    events: {} as { type: 'increment'; value: number }  }}).createMachine({  context: {    count: 0,  },  on: {    increment: {      actions: assign({        count: ({ context, event }) => context.count + event.value,      }),    },  },});const countActor = createActor(countMachine);countActor.subscribe((state) => {  console.log(state.context.count);});countActor.start();// logs 0countActor.send({ type: 'increment', value: 3 });// logs 3countActor.send({ type: 'increment', value: 2 });// logs 5
For more dynamic assignments, the argument passed to assign(...) may also be a function that returns the partial or full context value:
import { setup } from 'xstate';const countMachine = setup({  types: {    events: {} as { type: 'increment'; value: number }  }}).createMachine({  context: {    count: 0,  },  on: {    increment: {      actions: assign(({ context, event }) => {        return {          count: context.count + event.value,        };      }),    },  },});
Do not mutate the context object. Instead, you should use the assign(...) action to update context immutably. If you mutate the context object, you may get unexpected behavior, such as mutating the context of other actors.
You can create state machines with the assign(...) action in our drag-and-drop Stately editor. Read more about built-in assign action in Stately’s editor.
Raise action​
The raise action is a special action that raises an event that is received by the same machine. Raising an event is how a machine can “send” an event to itself:
import { createMachine, raise } from 'xstate';const machine = createMachine({  // ...  entry: raise({ type: 'someEvent', data: 'someData' });});
Internally, when an event is raised, it is placed into an “internal event queue”. After the current transition is finished, these events are processed in insertion order (first-in first-out, or FIFO). External events are only processed once all events in the internal event queue are processed.
Raised events can be dynamic:
import { createMachine, raise } from 'xstate';const machine = createMachine({  // ...  entry: raise(({ context, event }) => ({    type: 'dynamicEvent',    data: context.someValue,  }))});
Events can also be raised with a delay, which will not place them in the internal event queue, since they will not be immediately processed:
import { createMachine, raise } from 'xstate';const machine = createMachine({  // ...  entry: raise(    { type: 'someEvent' },    { delay: 1000 }  );});
You can create state machines with the raise(...) action in our drag-and-drop Stately editor. Read more about the built-in raise action in Stately’s editor.
Send-to action​
The sendTo(...) action is a special action that sends an event to a specific actor.
const machine = createMachine({  on: {    transmit: {      actions: sendTo('someActor', { type: 'someEvent' }),    },  },});
The event can be dynamic:
const machine = createMachine({  on: {    transmit: {      actions: sendTo('someActor', ({ context, event }) => {        return { type: 'someEvent', data: context.someData };      }),    },  },});
The destination actor can be the actor ID or the actor reference itself:
const machine = createMachine({  context: ({ spawn }) => ({    someActorRef: spawn(fromPromise(/* ... */)),  }),  on: {    transmit: {      actions: sendTo(({ context }) => context.someActorRef, {        type: 'someEvent',      }),    },  },});
Other options, such as delay and id, can be passed as the 3rd argument:
const machine = createMachine({  on: {    transmit: {      actions: sendTo(        'someActor',        { type: 'someEvent' },        {          id: 'transmission',          delay: 1000,        },      ),    },  },});
Delayed actions can be cancelled by their id. See cancel(...).
You can create state machines with the sendTo(...) action in our drag-and-drop Stately editor. Read more about the built-in sendTo action in Stately’s editor.
Send-parent action​
The sendParent(...) action is a special action that sends an event to the parent actor, if it exists.
It is recommended to use sendTo(...) by to pass actor refs (e.g. the parent actor ref) to other actors via input or events and storing those actor refs in context rather than using sendParent(...). This avoids tight coupling between actors and can be more type-safe.Example using input:import { createMachine, sendTo } from 'xstate';const childMachine = createMachine({  context: ({ input }) => ({    parentRef: input.parentRef  }),  on: {    someEvent: {      actions: sendTo(        ({ context }) => context.parentRef,        { type: 'tellParentSomething' }      ),    }  }});const parentMachine = createMachine({  // ...  invoke: {    id: 'child',    src: childMachine,    input: ({ self }) => ({      parentRef: self    })  },  on: {    tellParentSomething: {      actions: () => {        console.log('Child actor told parent something');      }    }  }});const parentActor = createActor(parentMachine);parentActor.start();
import { createMachine, sendParent } from 'xstate';const childMachine = createMachine({  on: {    someEvent: {      actions: sendParent({ type: 'tellParentSomething' }),    }  }});const parentMachine = createMachine({  // ...  invoke: {    id: 'child',    src: childMachine  },  on: {    tellParentSomething: {      actions: () => {        console.log('Child actor told parent something');      }    }  }});const parentActor = createActor(parentMachine);parentActor.start();
Enqueue actions​
The enqueueActions(...) action creator is a higher-level action that enqueues actions to be executed sequentially, without actually executing any of the actions. It takes a callback that receives the context, event as well as enqueue and check functions:

The enqueue(...) function is used to enqueue an action. It takes an action object or action function:
actions: enqueueActions(({ enqueue }) => {  // Enqueue an action object  enqueue({ type: 'greet', params: { message: 'hi' } });  // Enqueue an action function  enqueue(() => console.log('Hello'));  // Enqueue a simple action with no params  enqueue('doSomething');})

The check(...) function is used to conditionally enqueue an action. It takes a guard object or a guard function and returns a boolean that represents whether the guard evaluates to true:
actions: enqueueActions(({ enqueue, check }) => {  if (check({ type: 'everythingLooksGood' })) {    enqueue('doSomething');  }})

There are also helper methods on enqueue for enqueueing built-in actions:

enqueue.assign(...): Enqueues an assign(...) action
enqueue.sendTo(...): Enqueues a sendTo(...) action
enqueue.raise(...): Enqueues a raise(...) action
enqueue.spawnChild(...): Enqueues a spawnChild(...) action
enqueue.stopChild(...): Enqueues a stopChild(...) action
enqueue.cancel(...): Enqueues a cancel(...) action



Enqueued actions can be called conditionally, but they cannot be enqueued asynchronously.
const machine = createMachine({  // ...  entry: enqueueActions(({ context, event, enqueue, check }) => {    // assign action    enqueue.assign({      count: context.count + 1    });    // Conditional actions (replaces choose(...))    if (event.someOption) {      enqueue.sendTo('someActor', { type: 'blah', thing: context.thing });      // other actions      enqueue('namedAction');      // with params      enqueue({ type: 'greet', params: { message: 'hello' } });    } else {      // inline      enqueue(() => console.log('hello'));      // even built-in actions    }    // Use check(...) to conditionally enqueue actions based on a guard    if (check({ type: 'someGuard' })) {      // ...    }    // no return  })});
You can use parameters with referenced enqueue actions:
import { setup, enqueueActions } from 'xstate';const machine = setup({  actions: {    doThings: enqueueActions(({ enqueue }, params: { name: string }) => {      enqueue({ type: 'greet', params: { name } });      // ...    }),    greet: (_, params: { name: string }) => {      console.log(`Hello ${params.name}!`);    }  }}).createMachine({  // ...  entry: {    type: 'doThings',    params: { name: 'World' }  }});
Log action​
The log(...) action is an easy way to log messages to the console.
import { createMachine, log } from 'xstate';const machine = createMachine({  on: {    someEvent: {      actions: log('some message'),    },  },});
You can create state machines with the log(...) action in our drag-and-drop Stately editor. Read more about the built-in log action in Stately’s editor.
Cancel action​
The cancel(...) action cancels a delayed sendTo(...) or raise(...) action by their IDs:
import { createMachine, sendTo, cancel } from 'xstate';const machine = createMachine({  on: {    event: {      actions: sendTo(        'someActor',        { type: 'someEvent' },        {          id: 'someId',          delay: 1000,        },      ),    },    cancelEvent: {      actions: cancel('someId'),    },  },});
Stop child action​
The stopChild(...) action stops a child actor. Actors can only be stopped from their parent actor:
import { createMachine, stopChild } from 'xstate';const machine = createMachine({  context: ({ spawn }) => ({    spawnedRef: spawn(fromPromise(/* ... */), { id: 'spawnedId' }),  }),  on: {    stopById: {      actions: stopChild('spawnedId'),    },    stopByRef: {      actions: stopChild(({ context }) => context.spawnedRef),    },  },});
Modeling​
If you only need to execute actions in response to events, you can create a self-transition that only has actions: [ ... ] defined. For example, a machine that only needs to assign to context in transitions may look like this:
import { createMachine } from 'xstate';const countMachine = createMachine({  context: {    count: 0,  },  on: {    increment: {      actions: assign({        count: ({ context, event }) => context.count + event.value,      }),    },    decrement: {      actions: assign({        count: ({ context, event }) => context.count - event.value,      }),    },  },});
Shorthands​
For simple actions, you can specify an action string instead of an action object. Though we prefer using objects for consistency.
import { createMachine } from 'xstate';const feedbackMachine = createMachine({  // ...  states: {    // ...    question: {      on: {        'feedback.good': {          actions: ['track'],        },      },    },  },});
Actions and TypeScript​
XState v5 requires TypeScript version 5.0 or greater.For best results, use the latest TypeScript version. Read more about XState and TypeScript
To strongly setup action types, use the setup({ ... }) function and place the action implementations in the actions: { ... } object. The key is the action type and the value is the action function implementation.
You should also strongly type the parameters of the action function, which are passed as the second argument to the action function.
import { setup } from 'xstate';const machine = setup({  actions: {    track: (_, params: { response: string }) => {      // ...    },    increment: (_, params: { value: number }) => {      // ...    }  }}).createMachine({  // ...  entry: [    { type: 'track', params: { response: 'good' } },    { type: 'increment', params: { value: 1 } },  ]});
If you are not using setup({ ... }) (strongly recommended), you can strongly type the actions of your machine in the types.actions property of the machine config.
const machine = createMachine({  types: {} as {    actions:      | {          type: 'track';          params: {            response: string;          };        }      | { type: 'increment'; params: { value: number } };  },  // ...  entry: [    { type: 'track', params: { response: 'good' } },    { type: 'increment', params: { value: 1 } },  ],});
Actions cheatsheet​
Cheatsheet: entry and exit actions​
import { createMachine } from 'xstate';const machine = createMachine({  // Entry action on root  entry: [{ type: 'entryAction' }],  exit: [{ type: 'exitAction' }],  initial: 'start',  states: {    start: {      entry: [{ type:'startEntryAction' }],      exit: [{ type:'startExitAction' }],    }  }});
Cheatsheet: transition actions​
import { createMachine } from 'xstate';const machine = createMachine({  on: {    someEvent: {      actions: [        { type: 'doSomething' },        { type: 'doSomethingElse' },      ]    }  }});
Cheatsheet: inline action functions​
import { createMachine } from 'xstate';const machine = createMachine({  on: {    someEvent: {      actions: [        ({ context, event }) => {          console.log(context, event);        }      ]    }  }});
Cheatsheet: setting up actions​
import { setup } from 'xstate';const someAction = () => {  //...}const machine = setup({  actions: {    someAction  }}).createMachine({  entry: [    { type: 'someAction' }  ],  // ...})
Cheatsheet: providing actions​
import { setup } from 'xstate';const someAction = () => {  //...}const machine = setup({  actions: {    someAction  }}).createMachine({  // ...});const modifiedMachine = machine.provide({  someAction: () => {    // Overridden action implementation  }});
Cheatsheet: assign action​
With property assigners​
import { createMachine } from 'xstate';const countMachine = createMachine({  context: {    count: 0,  },  on: {    increment: {      actions: assign({        count: ({ context, event }) => {          return context.count + event.value;        }      }),    },  },});
With function assigners​
import { createMachine } from 'xstate';const countMachine = createMachine({  context: {    count: 0,  },  on: {    increment: {      actions: assign(({ context, event }) => {        return {          count: context.count + event.value        };      }),    },  },});
Cheatsheet: raise action​
import { createMachine, raise } from 'xstate';const machine = createMachine({  on: {    someEvent: {      actions: raise({ type: 'anotherEvent' }),    },  },});
Cheatsheet: send-to action​
const machine = createMachine({  on: {    transmit: {      actions: sendTo('someActor', { type: 'someEvent' }),    },  },});
Cheatsheet: enqueue actions​
import { createMachine, enqueueActions } from 'xstate';const machine = createMachine({  entry: enqueueActions(({ enqueue, check }) => {    enqueue({ type: 'someAction' });    if (check({ type: 'someGuard' })) {      enqueue({ type: 'anotherAction' });    }    enqueue.assign({      count: 0    })    enqueue.sendTo('someActor', { type: 'someEvent' });    enqueue.raise({ type: 'anEvent' })  })});

GuardsA guard is a condition function that the machine checks when it goes through an event. If the condition is true, the machine follows the transition to the next state. If the condition is false, the machine follows the rest of the conditions to the next state.
A guarded transition is a transition that is enabled only if its guard evaluates to true. The guard determines whether or not the transition can be enabled. Any transition can be a guarded transition.
You can easily visualize and simulate guarded transitions in Stately’s editor. Read more about guards in Stately’s editor.
Guards should be pure, synchronous functions that return either true or false.
const feedbackMachine = createMachine(  {    // ...    states: {      form: {        on: {          'feedback.submit': {            guard: 'isValid',            target: 'submitting',          },        },      },      submitting: {        // ...      },    },  },  {    guards: {      isValid: ({ context }) => {        return context.feedback.length > 0;      },    },  },);
View the  machine in Stately Studio.
Multiple guarded transitions​
If you want to have a single event transition to different states in certain situations, you can supply an array of guarded transitions. Each transition will be tested in order, and the first transition whose guard evaluates to true will be taken.
You can specify a default transition to be taken as the last transition in the array. If none of the guards evaluate to true, the default transition will be taken.
const feedbackMachine = createMachine({  // ...  prompt: {    on: {      'feedback.provide': [        // Taken if 'sentimentGood' guard evaluates to `true`        {          guard: 'sentimentGood',          target: 'thanks',        },        // Taken if none of the above guarded transitions are taken        // and if 'sentimentBad' guard evaluates to `true`        {          guard: 'sentimentBad',          target: 'form',        },        // Default transition        { target: 'form' },      ],    },  },});
Inline guards​
You can define guards as an inline function. This is useful for quickly prototyping logic but we generally recommended using serialized guards (strings or objects) for better reusability and visualization.
on: {  event: {    guard: ({ context, event }) => true,    target: 'someState'  }}
Guard object​
A guard can be defined as an object with a type, which is the type of guard that references the provided guard implementation, and optional params, which can be read by the implemented guard:
const feedbackMachine = createMachine(  {    // ...    states: {      // ...      form: {        on: {          submit: {            guard: { type: 'isValid', params: { maxLength: 50 } },            target: 'submitting',          },        },      },      // ...    },  },  {    guards: {      isValid: ({ context }, params) => {        return (          context.feedback.length > 0 &&          context.feedback.length <= params.maxLength        );      },    },  },);
Guards can later be provided or overridden by providing custom guard implementations in the .provide() method:
const feedbackActor = createActor(  feedbackMachine.provide({    guards: {      isValid: ({ context }, params) => {        return (          context.feedback.length > 0 &&          context.feedback.length <= params.maxLength &&          isNotSpam(context.feedback)        );      },    },  }),).start();
Higher-level guards​
XState provides higher-level guards, which are guards that compose other guards. There are three higher-level guards – and, or, and not:

and([...]) - evaluates to true if all guards in and([...guards]) evaluate to true
or([...]) - evaluates to true if any guards in or([...guards]) evaluate to true
not(...) - evaluates to true if the guard in not(guard) evaluates to false

on: {  event: {    guard: and(['isValid', 'isAuthorized']);  }}
Higher-level guards can be combined:
on: {  event: {    guard: and(['isValid', or(['isAuthorized', 'isGuest'])]);  }}
In-state guards​
You can use the stateIn(stateValue) guard to check if the current state matches the provided stateValue. This is most useful for parallel states.
on: {  event: {    guard: stateIn('#state1');  },  anotherEvent: {    guard: stateIn({ form: 'submitting' })  }}
In-state guards match the state of the entire machine, not the state node. There usually isn’t a need to use in-state guards for regular states. Try to model transitions in your state machines so that you don't need to use in-state guards first.
Shorthands​
It is recommended to define guards as guard objects, e.g. { type: 'someGuard', params: { ... } }. However, if a guard has no params, you can specify it as a string:
on: {  someEvent: {    // Equivalent to:    // guard: { type: 'someGuard' }    guard: 'someGuard';  }}
Guards and TypeScript​
XState v5 requires TypeScript version 5.0 or greater.For best results, use the latest TypeScript version. Read more about XState and TypeScript
You can strongly type the guards of your machine by setting up their implementations in setup({ guards: { … } }). You can provide the params type in the 2nd argument of the guard function:
import { setup } from 'xstate';const machine = setup({  guards: {    isGreaterThan: (_, params: { count: number; min: number; }) => {      return params.count > params.min;    }  }}).createMachine({  // ...  on: {    someEvent: {      guard: {        type: 'isGreaterThan',        // Strongly-typed params        params: ({ event }) => ({          count: event.count,          min: 10        })      },      // ...    },  },});
Guards cheatsheet​
import { createMachine } from 'xstate';const feedbackMachine = createMachine(  {    // ...    states: {      form: {        on: {          'feedback.submit': {            guard: 'isValid',            target: 'submitting',          },        },      },      submitting: {        // ...      },    },  },  {    guards: {      isValid: ({ context }) => {        return context.feedback.length > 0;      },    },  },);
Cheatsheet: multiple guarded transitions​
import { createMachine } from 'xstate';const feedbackMachine = createMachine({  // ...  prompt: {    on: {      'feedback.provide': [        // Taken if 'sentimentGood' guard evaluates to `true`        {          guard: 'sentimentGood',          target: 'thanks',        },        // Taken if none of the above guarded transitions are taken        // and if 'sentimentBad' guard evaluates to `true`        {          guard: 'sentimentBad',          target: 'form',        },        // Default transition        { target: 'form' },      ],    },  },});
Cheatsheet: Higher-level guards​
import { createMachine } from 'xstate';const loginMachine = createMachine({  on: {    event: {      guard: and(['isValid', 'isAuthorized']);    }  }});
Cheatsheet: Combined higher-level guards​
import { createMachine } from 'xstate';const loginMachine = createMachine({  on: {    event: {      guard: and(['isValid', or(['isAuthorized', 'isGuest'])]);    }  }});

Initial statesWhen a state machine starts, it enters the initial state first. A machine can only have one top-level initial state; if there were multiple initial states, the machine wouldn’t know where to start!
In XState, the initial state is defined by the initial property on the machine config:
const feedbackMachine = createMachine({  id: 'feedback',  // Initial state  initial: 'prompt',  // Finite states  states: {    prompt: {      /* ... */    },    // ...  },});
In our video player, paused is the initial state because the video player is paused by default and requires user interaction to start playing.
Watch our “What are initial states?” video on YouTube (1m17s).
<a href="https://stately.ai/registry/editor/embed/e13bef2b-bb13-4465-96ac-0bc25340688e?machineId=3ebc8874-2294-480b-a06e-74845337cd8d">View the <em>Video player</em> machine in Stately Studio</a>.
Specifying an initial state​
Typically, a state machine will have multiple finite states that it can be in. The initial property on the machine config specifies the initial state that the machine should start in.
Parent states also must specify an initial state in their initial property. The following trafficLightMachine will start in the 'green' state, as it is specified in the initial property of the machine config.
When the machine reaches the 'red' parent state, it will also be in the 'red.walk' state, as it is specified in the initial property of the 'red' state.
import { createMachine } from 'xstate';const trafficLightMachine = createMachine({  initial: 'green',  states: {    green: {/* ... */},    yellow: {/* ... */},    red: {      initial: 'walk',      states: {        walk: {/* ... */},        wait: {/* ... */},        stop: {/* ... */},      }    },  }});const trafficLightActor = createActor(trafficLightMachine);trafficLightActor.subscribe(state => {  console.log(state.value);});trafficLightActor.start();// logs 'green'

Finite statesA finite state is one of the possible states that a state machine can be in at any given time. It’s called “finite” because state machines have a known limited number of possible states. A state represents how a machine “behaves” when in that state; its status or mode.
For example in a feedback form, you can be in a state where you are filling out the form, or a state where the form is being submitted. You cannot be filling out the form and submitting it at the same time; this is an “impossible state.”
State machines always start at an initial state, and may end at a final state. The state machine is always in a finite state.
You can easily visualize and simulate intial and final states in Stately’s editor. Read more about states in Stately’s editor.
const feedbackMachine = createMachine({  id: 'feedback',  // Initial state  initial: 'prompt',  // Finite states  states: {    prompt: {      /* ... */    },    form: {      /* ... */    },    thanks: {      /* ... */    },    closed: {      /* ... */    },  },});
You can combine finite states with context, which make up the overall state of a machine:
const feedbackMachine = createMachine({  id: 'feedback',  context: {    name: '',    email: '',    feedback: '',  },  initial: 'prompt',  states: {    prompt: {      /* ... */    },  },});const feedbackActor = createActor(feedbackMachine).start();// Finite stateconsole.log(feedbackActor.getSnapshot().value);// logs 'prompt'// Context ("extended state")console.log(feedbackActor.getSnapshot().context);// logs { name: '', email: '', feedback: '' }
Initial state​
The initial state is the state that the machine starts in. It is defined by the initial property on the machine config:
const feedbackMachine = createMachine({  id: 'feedback',  // Initial state  initial: 'prompt',  // Finite states  states: {    prompt: {      /* ... */    },    // ...  },});
Read more about initial states.
State nodes​
In XState, a state node is a finite state “nodes” that comprise the entire statechart tree. State nodes are defined on the states property of other state nodes, including the root machine config (which itself is a state node):
// The machine is the root state nodeconst feedbackMachine = createMachine({  id: 'feedback',  initial: 'prompt',  // State nodes  states: {    // State node    prompt: {      /* ... */    },    // State node    form: {      /* ... */    },    // State node    thanks: {      /* ... */    },    // State node    closed: {      /* ... */    },  },});
Tags​
State nodes can have tags, which are string terms that help group or categorize the state node. For example, you can signify which state nodes represent states in which data is being loaded by using a “loading” tag, and determine if a state contains those tagged state nodes with state.hasTag(tag):
const feedbackMachine = createMachine({  id: 'feedback',  initial: 'prompt',  states: {    prompt: {      tags: ['visible'],      // ...    },    form: {      tags: ['visible'],      // ...    },    thanks: {      tags: ['visible', 'confetti'],      // ...    },    closed: {      tags: ['hidden'],    },  },});const feedbackActor = createActor(feedbackMachine).start();console.log(feedbackActor.getSnapshot().hasTag('visible'));// logs true
Read more about tags.
Meta​
Meta data is static data that describes relevant properties of a state node. You can specify meta data on the .meta property of any state node. This can be useful for displaying information about a state node in a UI, or for generating documentation.
The state.meta property collects the .meta data from all active state nodes and places them in an object with the state node’s ID as the key and the .meta data as the value:
const feedbackMachine = createMachine({  id: 'feedback',  initial: 'prompt',  meta: {    title: 'Feedback',  },  states: {    prompt: {      meta: {        content: 'How was your experience?',      },    },    form: {      meta: {        content: 'Please fill out the form below.',      },    },    thanks: {      meta: {        content: 'Thank you for your feedback!',      },    },    closed: {},  },});const feedbackActor = createActor(feedbackMachine).start();console.log(feedbackActor.getSnapshot().meta);// logs the object:// {//   feedback: {//     title: 'Feedback',//   },//   'feedback.prompt': {//     content: 'How was your experience?',//   }// }
Transitions​
Transitions are how you move from one finite state to another. They are defined by the on property on a state node:
import { createMachine, createActor } from 'xstate';const feedbackMachine = createMachine({  initial: 'prompt',  states: {    prompt: {      on: {        'feedback.good': {          target: 'thanks',        },      },    },    thanks: {      /* ... */    },    // ...  },});const feedbackActor = createActor(feedbackMachine).start();console.log(feedbackActor.getSnapshot().value);// logs 'prompt'feedbackActor.send({ type: 'feedback.good' });console.log(feedbackActor.getSnapshot().value);// logs 'thanks'
Read more about events and transitions.
Targets​
A transition’s target property defines where the machine should go when the transition is taken. Normally, it targets a sibling state node:
import { createMachine, createActor } from 'xstate';const feedbackMachine = createMachine({  initial: 'prompt',  states: {    prompt: {      on: {        'feedback.good': {          // Targets the sibling `thanks` state node          target: 'thanks',        },      },    },    thanks: {      /* ... */    },    // ...  },});
The target can also target a descendant of a sibling state node:
import { createMachine, createActor } from 'xstate';const feedbackMachine = createMachine({  initial: 'prompt',  states: {    prompt: {      on: {        'feedback.good': {          // Targets the sibling `thanks.happy` state node          target: 'thanks.happy',        },      },    },    thanks: {      initial: 'normal',      states: {        normal: {},        happy: {},      },    },    // ...  },});
When the target state node is a descendant of the source state node, the source state node key can be omitted:
import { createMachine, createActor } from 'xstate';const feedbackMachine = createMachine({  // ...  states: {    closed: {      initial: 'normal',      states: {        normal: {},        keypress: {},      },    },  },  on: {    'feedback.close': {      // Targets the descendant `closed` state node      target: '.closed',    },    'key.escape': {      // Targets the descendant `closed.keypress` state node      target: '.closed.keypress',    },  },});
When the state node doesn’t change; i.e., the source and target state nodes are the same, the target property can be omitted:
import { createMachine, createActor } from 'xstate';const feedbackMachine = createMachine({  // ...  states: {    form: {      on: {        'feedback.update': {          // No target defined – stay on the `form` state node          // Equivalent to `target: '.form'` or `target: undefined`          actions: 'updateForm',        },      },    },  },});
State nodes can also be targeted by their id by prefixing the target with a # followed by the state node's id:
import { createMachine, createActor } from 'xstate';const feedbackMachine = createMachine({  initial: 'prompt',  states: {    closed: {      id: 'finished',    },    // ...  },  on: {    'feedback.close': {      target: '#finished',    },  },});
Identifying state nodes​
States can be identified with a unique ID: id: 'myState'. This is useful for targeting a state from any other state, even if they have different parent states:
import { createMachine, createActor } from 'xstate';const feedbackMachine = createMachine({  initial: 'prompt',  states: {    // ...    closed: {      id: 'finished',      type: 'final',    },    // ...  },  on: {    'feedback.close': {      // Target the `.closed` state by its ID      target: '#finished',    },  },});
State IDs do not affect the state.value. In the above example, the state.value would still be closed even though the state node is identified as #finished.
Other state types​
In statecharts, there are other types of states:

Parent states (also known as compound states)
Parallel states
History states
Final states

Modeling states​

Start simple and shallow. Don’t create multiple finite states until it becomes apparent that the behavior of your logic differs depending on some finite state it can be in.
Can model choice pseudostates

Finite states and TypeScript​
XState v5 requires TypeScript version 5.0 or greater.For best results, use the latest TypeScript version. Read more about XState and TypeScript
Coming soon
Finite states cheatsheet​
Coming soon

Parent statesStates can contain more states, also known as child states. These child states are only active when the parent state is active.
Child states are nested inside their parent states. Parent states are also known as compound states.
You can easily visualize and simulate parent and child states in Stately’s editor. Read more about parent states in Stately’s editor.
Watch our “Parent and child states” video on YouTube (1m6s).
<a href="https://stately.ai/registry/editor/embed/e13bef2b-bb13-4465-96ac-0bc25340688e?machineId=9ba5377c-aab3-4465-8909-4eea499622fa">View the <em>Video player</em> machine in Stately Studio</a>.
In the video player above, the Opened state is a parent state to the Playing, Paused, and Stopped states. These states, their transitions, and their events are nested inside the Opened state.
Root state​
The state machine itself is a parent state! It’s the root state, and it’s always active.
It’s normal to have a state machine that has no other states. This is useful for modeling a simple state machine that only handles events by executing actions in transitions.
Here is an example of a simple counting machine with increment, decrement, and reset events, and no states, other than the implicit top-level root state:
import { createMachine } from 'xstate';const countingMachine = createMachine({  id: 'counting',  on: {    increment: {      actions: assign({ count: ({ context }) => context.count + 1 }),    },    decrement: {      actions: assign({ count: ({ context }) => context.count - 1 }),    },    reset: {      actions: assign({ count: 0 }),    },  },  // No child states!});
Initial state​
The initial state of a parent state is the state that is entered when the parent state is entered. Parent states must have an initial states.
You specify the initial state via the initial property of the parent state, which is the key of the initial state in the states object:
import { createMachine } from 'xstate';const feedbackMachine = createMachine({  initial: 'question',  states: {    question: {      // ...    },    form: {      // ...    },    thanks: {      // ...    },  },});
Even if the parent state is never directly targeted and its child states are instead targeted, specifying the initial state in the .initial property is required. In this case, the .initial property can be any of the child states.
Transitions on parent states​
A transition that targets a parent state will enter the parent state and its initial state. If that initial state is a parent state, then that state’s initial state will be entered, and so on.
When an event is received, transitions on the deepest child nodes are checked first to see if any of them are enabled by that event. If no transitions are enabled, then transitions on the parent state are checked. If no transitions on the parent state are enabled, then transitions on the parent's parent state is checked, and so on.
Transitions on a parent state can target child (or descendent) states. This is useful for modeling a transition that should go to a specific child state regardless of which child state is currently active.
Transitions on a child state can target the parent state, though this is not common. A transition from a child state to its parent (or ancestor) state will also enter the parent state’s initial state.
Child final states​
When a child final state of a parent state is reached, that parent state is considered "done". The onDone transition of that parent state is automatically taken.
import { createMachine } from 'xstate';const coffeeMachine = createMachine({  initial: 'preparation',  states: {    preparation: {      initial: 'weighing',      states: {        weighing: {          on: {            weighed: {              target: 'grinding'            }          }        },        grinding: {          on: {            ground: 'ready'          }        },        ready: {          // Child final state of parent state 'preparation'          type: 'final'        }      },      // Transition will be taken when child final state is reached      onDone: {        target: 'brewing'      }    },    brewing: {      // ...    }  }});
Modeling​
Coming soon

Start with a flat structure; don’t create parent states too early
If many states have common outgoing transitions, that’s a good sign for putting them in a parent state
Parent states also represent sub-processes.

Parent states cheatsheet​
Cheatsheet: creating parent states​
// The machine is the root-level parent stateconst machine = createMachine({  // Initial child state of the machine  initial: 'parent',  states: {    parent: {      // Initial child state of the parent state      initial: 'child1',      states: {        child1: {          on: {            // Targeting a sibling            toSibling: {              target: 'child2',            },          },        },        child2: {          initial: 'grandchild1',          states: {            grandchild1: {},            grandchild2: {},          },        },      },      on: {        // Targeting a child        toChild: {          target: '.child1',        },        // Targeting a grandchild        toGrandchild: {          target: '.child2.grandchild2',        },      },    },  },});

Parallel statesIn statecharts, a parallel state is a state that has multiple child states (also known as regions) that are all active at the same time. This is different from a parent state, where only one child state is active at a time.
Parallel states have the following characteristics:

Entering a parallel state will also simultaneously enter all of its regions.
Exiting a parallel state will also simultaneously exit all of its regions.
An event received in a parallel state is simultaneously received & handled by all of its regions.

You can easily visualize and simulate parallel states in Stately’s editor. Read more about parallel states in Stately’s editor.
Here is a music player example with a parallel state consisting of two regions, one for handling playing the track and one for handling the volume:
import { createMachine, assign } from 'xstate';const playerMachine = createMachine({  id: 'player',  type: 'parallel',  states: {    track: {      initial: 'paused',      states: {        paused: {          on: { PLAY: 'playing' },        },        playing: {          on: { STOP: 'paused' },        },      },    },    volume: {      initial: 'normal',      states: {        normal: {          on: { MUTE: 'muted' },        },        muted: {          on: { UNMUTE: 'normal' },        },      },    },  },});
View the Video player machine in Stately Studio.
Parallel state value​
The state value of a parallel state is an object with the state values of each of its regions.
const playerActor = createActor(playerMachine);playerActor.start();console.log(playerActor.getSnapshot().value);// logs the object:// {//   track: 'paused',//   volume: 'normal'// }
Parallel onDone transition​
When all regions of a parallel state have reached their final states, the onDone transition of the parallel state is taken.
In this example, the onDone transition of the parallel state is taken when both regions have reached their final states; that is, when 'grindingBeans' reaches the 'grindingBeans.beansGround' state and 'boilingWater' reaches the 'boilingWater.waterBoiled' state.
import { createMachine } from "xstate";export const machine = createMachine({  id: "coffee",  initial: "preparing",  states: {    preparing: {      states: {        grindBeans: {          initial: "grindingBeans",          states: {            grindingBeans: {              on: {                BEANS_GROUND: {                  target: "beansGround",                },              },            },            beansGround: {              type: "final",            },          },        },        boilWater: {          initial: "boilingWater",          states: {            boilingWater: {              on: {                WATER_BOILED: {                  target: "waterBoiled",                },              },            },            waterBoiled: {              type: "final",            },          },        },      },      type: "parallel",      onDone: {        target: "makingCoffee",      },    },    makingCoffee: {},  },});
View the  machine in Stately Studio.
Modeling​
Coming soon

Avoid transitions between regions
Used for separation of concerns that may affect each other (i.e. synchronization)
If completely separate, prefer invoke instead

Parallel states cheatsheet​
Cheatsheet: create a parallel state​
import { createMachine } from "xstate";const machine = createMachine({  // ...  states: {    type: 'parallel',    states: {      one: {/* ... */},      two: {/* ... */},      three: {/* ... */}    },    onDone: {      // Taken when all regions have reached their final states    }  }});

Final statesA final state is a state that represents the completion or successful termination of a machine. It is defined by the type: 'final' property on a state node:
import { createMachine, createActor } from 'xstate';const feedbackMachine = createMachine({  initial: 'prompt',  states: {    prompt: {      /* ... */    },    thanks: {      /* ... */    },    closed: {      type: 'final',    },    // ...  },  on: {    'feedback.close': {      target: '.closed',    },  },});
View the  machine in Stately Studio.
When a machine reaches the final state, it can no longer receive any events, and anything running inside it is canceled and cleaned up. The box with a surrounding border icon represents the final state.
A machine can have multiple final states or no final states.

A state machine can have zero or more final states. Some machines may run indefinitely and not need to terminate.
Final states can have output data, which is sent to the parent machine when the machine terminates.
When a machine reaches a top-level final state, it terminates.
Final states cannot have transitions

Top-level final states​
A top-level final state is a final state that is a direct child state of the machine. When the machine reaches a top-level final state, the machine will terminate. When a machine terminates, it can no longer receive events nor transition.
Child final states​
When a child final state of a parent (compound) state is reached, that parent state is considered "done". The onDone transition of that parent state is automatically taken.
import { createMachine } from 'xstate';const coffeeMachine = createMachine({  initial: 'preparation',  states: {    preparation: {      initial: 'weighing',      states: {        weighing: {          on: {            weighed: {              target: 'grinding'            }          }        },        grinding: {          on: {            ground: 'ready'          }        },        ready: {          // Child final state of parent state 'preparation'          type: 'final'        }      },      // Transition will be taken when child final state is reached      onDone: {        target: 'brewing'      }    },    brewing: {      // ...    }  }});
Final states in parallel states​
When all regions of a parallel state are "done", the parallel state is considered "done". The onDone transition of the parallel state is taken.
In this example, the preparation state is a parallel state with two regions: beans and water. When both regions are done, the preparation state is done, and the brewing state is entered.
import { createMachine, createActor } from 'xstate';const coffeeMachine = createMachine({  initial: 'preparation',  states: {    preparation: {      type: 'parallel',      states: {        beans: {          initial: 'grinding',          states: {            grinding: {              on: {                grindingComplete: 'ground',              },            },            ground: {              type: 'final',            },          },        },        water: {          initial: 'heating',          states: {            heating: {              always: {                guard: 'waterBoiling',                target: 'heated',              },            },            heated: {              type: 'final',            },          },        },      },      onDone: 'brewing',    },    brewing: {},  },});
View the  machine in Stately Studio.
Output​
When a machine reaches its top-level final state, it can produce output data. You can specify this output data in the .output property of the machine config:
import { createMachine, createActor } from 'xstate';const currencyMachine = createMachine({  // ...  states: {    converting: {      // ...    },    converted: {      type: 'final',    },  },  output: ({ context }) => ({    amount: context.amount,    currency: context.currency,  }),});const currencyActor = createActor(currencyMachine, {  input: {    amount: 10,    fromCurrency: 'USD',    toCurrency: 'EUR',  },});currencyActor.subscribe({  complete() {    console.log(currencyActor.getSnapshot().output);    // logs e.g. { amount: 12, currency: 'EUR' }  },});
The .output property can also be a static value:
import { createMachine, createActor } from 'xstate';const processMachine = createMachine({  // ...  output: {    message: 'Process completed.',  },});
Final states cheatsheet​
import { createMachine } from 'xstate';const feedbackMachine = createMachine({  initial: 'prompt',  states: {    prompt: {      /* ... */    },    thanks: {      /* ... */    },    closed: {      type: 'final',    },    // ...  },  on: {    'feedback.close': {      target: '.closed',    },  },});
Cheatsheet: final states in parallel states​
import { createMachine} from 'xstate';const coffeeMachine = createMachine({  initial: 'preparation',  states: {    preparation: {      type: 'parallel',      states: {        beans: {          initial: 'grinding',          states: {            grinding: {              on: {                grindingComplete: 'ground',              },            },            ground: {              type: 'final',            },          },        },        water: {          initial: 'heating',          states: {            heating: {              always: {                guard: 'waterBoiling',                target: 'heated',              },            },            heated: {              type: 'final',            },          },        },      },      onDone: 'brewing',    },    brewing: {},  },});

History statesA history state is a special type of state (a pseudostate) that remembers the last child state that was active before its parent state is exited. When a transition from outside the parent state targets a history state, the remembered child state is entered.
This allows machines to "remember" where they left off when exiting and reentering a parent state.

If no child state remembered, history goes to .target state, if it is specified
Otherwise, go to initial state

A history state returns the parent state to its most recently active child state. The box with an H inside represents the history state.
The history state can be deep or shallow:

A shallow history state remembers the immediate child’s state.
A deep history state remembers the deepest active state or states inside its child states.

const checkoutMachine = createMachine({  // ...  states: {    payment: {      initial: 'card',      states: {        card: {},        paypal: {},        hist: { type: 'history' },      },    },    address: {      on: {        back: {          target: 'payment.hist',        },      },    },  },});
Shallow vs. deep history​

Shallow history states only remember the last active direct child state.
Deep history states remember all active descendant states.

History target​

Normally, history states target the most recent child state of its parent state
If the history state is entered but the parent state was never visited, the parent's initial state is entered.
However, you can add a target: 'childKey' to specify the default child state that should be entered

History states cheatsheet​
Cheatsheet: create a history state (shallow by default)​
const machine = createMachine({  // ...  states: {    hist: { type: 'history' },    firstState: {},    someState: {},    anotherState: {},  },});
Cheatsheet: create a deep history state​
const machine = createMachine({  // ...  states: {    hist: {      type: 'history',      history: 'deep',    },    firstState: {},    someState: {},    anotherState: {},  },});
Cheatsheet: create a history state with a target​
const machine = createMachine({  // ...  initialState: 'firstState',  states: {    hist: {      type: 'history',      target: 'someState',    },    firstState: {},    someState: {},    anotherState: {},  },});

PersistenceActors can persist their internal state and restore it later. Persistence refers to storing the state of an actor in persistent storage, such as localStorage or a database. Restoration refers to restoring the state of an actor from persistent storage.
In frontend applications, persistence is useful for maintaining state across browser reloads. In backend applications, persistence allows workflows to span multiple requests, survive service restarts, be fault-tolerant, represent long-running processes, and be auditable and traceable.
In XState, you can obtain the snapshot (state) to be persisted via actor.getPersistedSnapshot() and restore it via createActor(behavior, { snapshot: restoredState }).start():
const feedbackActor = createActor(feedbackMachine).start();// Get state to be persistedconst persistedState = feedbackActor.getPersistedSnapshot();// Persist statelocalStorage.setItem('feedback', JSON.stringify(persistedState));// Restore stateconst restoredState = JSON.parse(localStorage.getItem('feedback'));const restoredFeedbackActor = createActor(feedbackMachine, {  snapshot: restoredState,}).start();
Persisting state​
You can obtain the state to be persisted via actor.getPersistedSnapshot():
const feedbackActor = createActor(feedbackMachine).start();// Get state to be persistedconst persistedState = feedbackActor.getPersistedSnapshot();
The internal state can be persisted from any actor, not only machines. Note that the persisted state is not the same as the snapshot from actor.getSnapshot(); persisted state represents the internal state of the actor, while snapshots represent the actor's last emitted value:
const promiseActor = fromPromise(() => Promise.resolve(42));// Get the last emitted valueconst snapshot = promiseActor.getSnapshot();console.log(snapshot);// logs 42// Get the persisted stateconst persistedState = promiseActor.getPersistedSnapshot();console.log(persistedState);// logs { status: 'done', data: 42 }
Restoring state​
You can restore an actor to a persisted state by passing the persisted state into the state option of the second argument of createActor(logic, { snapshot: restoredState }):
// Get persisted stateconst restoredState = JSON.parse(localStorage.getItem('feedback'));// Restore stateconst feedbackActor = createActor(feedbackMachine, {  snapshot: restoredState,});feedbackActor.start();
Actions from machine actors will not be re-executed, because they are assumed to have been already executed. However, invocations will be restarted, and spawned actors will be restored recursively.
Deep persistence​
Persisting & restoring state from machine actors is deep; all invoked & spawned actors will be persisted and restored recursively.
const feedbackMachine = createMachine({  // ...  states: {    form: {      invoke: {        id: 'form',        src: formMachine,      },    },  },});const feedbackActor = createActor(feedbackMachine).start();// Persist stateconst persistedState = feedbackActor.getPersistedSnapshot();localStorage.setItem('feedback', JSON.stringify(persistedState));//  ...// Restore stateconst restoredState = JSON.parse(localStorage.getItem('feedback'));const restoredFeedbackActor = createActor(feedbackMachine, {  snapshot: restoredState,}).start();// Will restore both the feedbackActor and the invoked form actor at// their persisted states
Persisting state machine values​
If you want to persist only the finite state value (and optionally the context) of a state machine actor, you can use the machine.resolveState(...) method:
import { someMachine } from './someMachine';const restoredStateValue = localStorage.getItem('someState');// Assume that this is "pending"const resolvedState = someMachine.resolveState({  value: restoredStateValue,  // context: { ... }});// Restore the actorconst restoredActor = createActor(someMachine, {  snapshot: resolvedState});restoredActor.start();
Event sourcing​
An alternative to persisting state is event sourcing, which is a way of restoring the state of an actor by replaying the events that led to that state. Event sourcing can be more reliable than persisting state, because it is less prone to incompatible state and it also allows you to replay actions.
One way to implement event sourcing is to persist the events as they happen using the inspection API, and then replay them to restore the state of the actor:
const events = [];const someActor = createActor(someMachine, {  // Inspect and persist events  inspect: (inspectionEvent) => {    if (inspectionEvent.type === '@xstate.event') {      const event = inspectionEvent.event;      // Only listen for events sent to the root actor      if (inspectionEvent.actorRef !== someActor) { return; }      events.push(event);    }  }});someActor.start();// ...// Assuming the events are stored somewhere, e.g. in localStorage,// you can replay them to restore the state of the actorconst restoredActor = createActor(someMachine);restoredActor.start();for (const event of events) {  // Replay events  restoredActor.send(event);}
Caveats​
There are some caveats to persisting and restoring state that you should be aware of:

Incompatible state: if the machine or actor logic changes, the restored state may be incompatible with the new logic.
Replaying actions: actions that have already been executed will not be re-executed. Event sourcing is preferred for this use-case.
Serialization: the state must be serializable, which means that it must be JSON-serializable. This means that you cannot persist functions, classes, or other non-serializable values.

Persistence cheatsheet​
Cheatsheet: persisting state​
const persistedState = actor.getPersistedSnapshot();
Cheatsheet: restoring state​
const restoredState = JSON.parse(localStorage.getItem('feedback'));const restoredActor = createActor(actorMachine, {  snapshot: restoredState,}).start();
Resources​

Blog: Persisting state in XState


TagsState nodes can have tags, which are string terms that help group or categorize the state node. For example, you can signify which state nodes represent states in which data is being loaded by using a "loading" tag, and determine if a state contains those tagged state nodes with state.hasTag(tag):
const feedbackMachine = createMachine({  id: 'feedback',  initial: 'prompt',  states: {    prompt: {      tags: ['visible'],      // ...    },    form: {      tags: ['visible'],      // ...    },    thanks: {      tags: ['visible', 'confetti'],      // ...    },    closed: {      tags: ['hidden'],    },  },});const feedbackActor = createActor(feedbackMachine).start();console.log(feedbackActor..getSnapshot().hasTag('visible'));// logs true
Tags and TypeScript​
XState v5 requires TypeScript version 5.0 or greater.For best results, use the latest TypeScript version. Read more about XState and TypeScript
You can strongly type the tags of your machine in the types.tags property of the machine setup.
import { setup } from 'xstate';const machine = setup({  types: {    tags: {} as 'pending' | 'success' | 'error'  }}).createMachine({  // ...  states: {    loadingUser: {      tags: ['pending'], // Strongly-typed    },  },});const actor = createActor(machine).start();actor  .getSnapshot()  // Autocompleted  .hasTag('pending');

Event emitterSince XState version 5.9.0
State machines and other types of actor logic in XState have the ability to emit events. This allows external event handlers to be notified of specific events.
With state machines, you can emit events using the emit(event) action creator.
import { setup, emit } from 'xstate';const machine = setup({  actions: {    emitEvent: emit({ type: 'notification' })  }}).createMachine({  // ...  on: {    someEvent: {      actions: { type: 'emitEvent' }    }  }});const actor = createActor(machine);actor.on('notification', (event) => {  console.log('Notification received!', event);});actor.start();actor.send({ type: 'someEvent' });// Logs:// "Notification received!"// { type: "notification" }
Emitting events from actor logic​
For promise actors, transition actors, observable actors, and callback actors, you can use the emit method from the arguments to emit events.
Promise actors
import { fromPromise } from 'xstate';const logic = fromPromise(async ({ emit }) => {  // ...  emit({    type: 'emitted',    msg: 'hello'  });  // ...});
Transition actors
import { fromTransition } from 'xstate';const logic = fromTransition((state, event, { emit }) => {  // ...  emit({    type: 'emitted',    msg: 'hello'  });  // ...  return state;}, {});
Observable actors
import { fromObservable } from 'xstate';const logic = fromObservable(({ emit }) => {  // ...  emit({    type: 'emitted',    msg: 'hello'  });  // ...});
Callback actors
import { fromCallback } from 'xstate';const logic = fromCallback(({ emit }) => {  // ...  emit({    type: 'emitted',    msg: 'hello'  });  // ...});
Emit action creator​
The emit action is a special action that emits an event to any external event handlers from state machine logic. The emitted event can be statically or dynamically defined:
import { setup, emit } from 'xstate';const machine = setup({  actions: {    // Emitting a statically-defined event    emitStaticEvent: emit({      type: 'someStaticEvent',      data: 42    }),    // Emitting a dynamically-defined event based on context    emitDynamicEvent: emit(({ context }) => ({      type: 'someDynamicEvent',      data: context.someData    }))  }}).createMachine({  // ...  on: {    someEvent: {      actions: [        { type: 'emitStaticEvent' },        { type: 'emitDynamicEvent' }      ]    }  }});
Event handlers​
You can attach event handlers to the actor to listen for emitted events by using actor.on(event, handler):
const someActor = createActor(someMachine);someActor.on('someEvent', (emittedEvent) => {  // Handle the emitted event  console.log(emittedEvent);});someActor.start();
The actor.on(…) method returns a subscription object. You can call .unsubscribe() on it to remove the handler:
const someActor = createActor(someMachine);const subscription = someActor.on('someEvent', (emittedEvent) => {  // Handle the emitted event  console.log(emittedEvent);});someActor.start();// ...// Stop listening for eventssubscription.unsubscribe();
Wildcard event handlers​
You can listen for any emitted event by listening for the wildcard '*':
const someActor = createActor(someMachine);actor.on('*', (emitted) => {  console.log(emitted); // Any emitted event});
The emitted event will be typed as the union of all possible events that can be emitted from the machine.
TypeScript​
You can strongly type emitted events by defining the emitted event types in the types.emitted property of the setup(…) function:
import { setup, emit, createActor } from 'xstate';const machine = setup({  types: {    emitted: {} as       | { type: 'notification'; message: string; }      | { type: 'error'; error: Error; },    // ...  }}).createMachine({  // ...  on: {    someEvent: {      actions: [        // Strongly typed emitted event        emit({ type: 'notification', message: 'Hello' })      ]    }  }});const actor = createActor(machine);// Strongly typed event handleractor.on('notification', (event) => {  console.log(event.message); // string});

TestingTesting logic​
Testing actor logic is important for ensuring that the logic is correct and that it behaves as expected. You can test your state machines and actors using various testing libraries and tools. You should follow the Arrange, Act, Assert pattern when writing tests for your state machines and actors:

Arrange - set up the test by creating the actor logics (such as a state machine) and the actors from the actor logics.
Act - send event(s) to the actor(s).
Assert - assert that the actor(s) reached their expected state(s) and/or executed the expected side effects.

import { setup, createActor } from 'xstate';import { test, expect } from 'vitest';test('some actor', async () => {  const notifiedMessages: string[] = [];  // 1. Arrange  const machine = setup({    actions: {      notify: (_, params) => {        notifiedMessages.push(params.message);      }    }  }).createMachine({    initial: 'inactive',    states: {      inactive: {        on: { toggle: { target: 'active' } }      },      active: {        entry: { type: 'notify', params: { message: 'Active!' } },        on: { toggle: { target: 'inactive' } }      }    }  });  const actor = createActor(machine);  // 2. Act  actor.start();  actor.send({ type: 'toggle' }); // => should be in 'active' state  actor.send({ type: 'toggle' }); // => should be in 'inactive' state  actor.send({ type: 'toggle' }); // => should be in 'active' state  // 3. Assert  expect(actor.getSnapshot().value).toBe('active');  expect(notifiedMessages).toEqual(['Active!', 'Active!']);;});
You can now generate test paths from your state machines in Stately Studio. You can try Stately Studio’s premium plans with a free trial. Check out the features on our Pro plan, Team plan, Enterprise plan or upgrade your existing plan.
Testing actors​
Coming soon
Mocking effects​
Coming soon
Using @xstate/test​
Coming soon

Usage with ImmerImmer is a library that makes it more convenient to work with updating data immutably. It can be used with XState to immutably update context in assignments.
It is recommended to use Immer directly with XState instead of the @xstate/immer package, which is deprecated.
Installation​
Install the latest versions of xstate and immer from npm:
npmpnpmyarnnpm install xstate immerpnpm install xstate immeryarn add xstate immer
See the Immer installation docs for more information.
Immer usage​
XState already allows you to immutably update context partially or completely in assign actions. However, for more complex scenarios, you may want to use Immer to update context in a less verbose way.
import { createMachine, assign } from 'xstate';import { produce } from 'immer';const machine = createMachine({  id: 'todos',  context: {    todos: [],    filter: 'all'  },  // ...  on: {    'todo.complete': {      // Using Immer to update a single context property      actions: assign({        todos: ({ context, event }) => produce(context.todos, draftTodos => {          const todo = draftTodos.find(t => t.id === event.todo.id);          todo.completed = true;        })      })    },    'todos.add': {      // Using Immer to update multiple context properties      actions: assign(({ context, event }) => produce(context, draftContext => {        draftContext.todos.push({          id: event.todo.id,          description: event.todo.description,          completed: false        });        if (draftContext.filter === 'all') {          draftContext.filter = 'active';        }      }))    }  }});

XState VS Code extension
The XState VS Code extension enhances the XState development experience by providing VS Code users with autocomplete, typegen, linting, and a visual editor inside VS Code.
If you don’t use VS Code but use an open source code editor that supports VS Code extensions, you can download the XState VS Code extension from the OpenVSX registry.
Installation​

Open the command palette with shift + cmd/ctrl + p.
Search for the Install Extensions command and hit enter to open the Extensions search.
Search for XState to find the XState VS Code extension and install the extension using the Install button.
Ensure you have VS Code setup to insert spaces; we have noticed problems when tabs are used for indentation.

Once installed, you can run XState: Open Visual Editor from the command palette to open any machine at your cursor’s location.
If you have code lens enabled (this can be enabled using editor.codeLens setting), ‘Open Visual Editor’ will also float above each createMachine call.
You can also download the VS Code extension from the VS Code marketplace or download the VS Code extension from the Open VSX marketplace.
Features​

Visually edit machines. Edit any XState machine with drag-and-drop using the integrated Stately Visual editor.
Autocomplete. Intelligent suggestions for transition targets and initial states.
Linting. Highlights errors and potential bugs in your XState machine definitions.
Jump to definition. Navigate around machines easily with jump to definition on targets, actions, guards, actors and more.

TypeScript typegen​
You can automatically generate intelligent typings for XState with our VS Code extension and command line interface. Read more about how to use typegen, and our recommended best practices, on the Typegen page.
xsm snippet​
Use the xsm snippet to generate the code required for your state machine quickly. Watch the ‘XState + VS Code: xsm snippet’ video (1m23s) for a demo.
Refactors​
When hovering over a named action, guard or actor in a machine, press the lightbulb icon to view available refactors.
Ignoring machines​
If you’d like to ignore linting/autocomplete on a machine, add an // xstate-ignore-next-line comment on the line above the machine:
// xstate-ignore-next-linecreateMachine({});
Machine layout persistence​Upon opening an XState machine in VS Code, you may notice a long @xstate-layout comment inserted in the code just above the call to createMachine().const machine =/** @xstate-layout N4IgpgJg5mDOIC5QFEA... */createMachine({...});This layout string is for persisting manual changes you make to the machine’s layout and is automatically updated by the XState Extension whenever layout changes occur. It is not intended to be human-readable nor manually edited. When updates to this string are made by the extension, the file is not saved until a manual save is performed. The layout algorithm is able to interpret this string and automatically format the machine's layout whenever it is re-opened in Stately Studio’s editor.
Caution: if you use tab based-indentation in VS Code the extension might not work. Setup VS Code to insert spaces automatically.

Visualizer (Legacy)
Are you looking for the Stately Studio visual editor? Check out the Stately Studio overview.

The Stately Visualizer is a tool for creating and inspecting statecharts to visualize the state of your applications. You can use the viz as a playground for exploring XState’s capabilities.
The XState Visualizer is deprecated and is no longer maintained.
We recommend you only continue using the legacy visualizer if you need to execute actions and guards or visualize multiple machines simultaneously. These features are coming to the Stately editor very soon.
Use the Visualizer​

Take me to the Visualizer
Try the Visualizer in Inspect mode.

The Visualizer is deprecated and we encourage you to migrate your projects to use the Stately editor.
Feedback and bug reports​
If you have any feedback or feature requests, please join our Discord server, where you’ll find our team and the wonderful Stately community.
Please submit any bug reports as GitHub issues on the XState repository.

Stately Inspector
Stately Inspector is a tool that allows you to inspect your application’s state visually. It primarily works with frontend applications using XState but can also work with backend code and code that uses any state management solution.
Read about our recent release of Stately Inspector on our blog.
Install Stately Inspector​
To inspect applications with Stately Inspector, install Stately Inspect from npm via @statelyai/inspect:
npm install @statelyai/inspect
Then import the relevant inspector creator into your app. The creator is used to create an inspector (e.g., a browser or WebSocket inspector) that you can use to either connect to XState actors and/or manually send inspection events to Stately Inspector:
import { createActor } from 'xstate';import { createBrowserInspector } from '@statelyai/inspect';import { machine } from './machine';const { inspect } = createBrowserInspector();// ...const actor = createActor(machine, {  inspect,  // ... other actor options});actor.start();
When you run your app, a new tab or popup window will open with the Inspector.
When using the browser inspector, ensure that the popup window is not blocked by your browser’s popup blocker.
Inspector options​
You can pass the following options to the browser inspector:

filter - a function that takes an inspection event and returns true if the event should be sent to the Stately Inspector.
serialize - a function that takes an inspection event and allows you to serialize it before sending it to the Stately Inspector.
autoStart - whether to automatically start the inspector. Defaults to true.

If autoStart: false, you can start the inspector by calling inspector.start().


url - the URL of the Stately Inspector to open. Defaults to https://stately.ai/inspector.
iframe - the <iframe> element to use for the inspector. Defaults to null.

Example usage:
import { createBrowserInspector } from '@statelyai/inspect';const inspector = createBrowserInspector({  filter: (inspEvent) => {    if (inspEvent.type === '@xstate.event') {      // Skip mouse drag events      return inspEvent.event.type !== 'mouse.drag';    }    return true;  },  iframe: document.getElementById('inspector-iframe')})
Sending inspection events​
The @statelyai/inspect package will send inspection events to the connected Stately Inspector. There are currently three kinds of events sent:

Actor creation events
Actor-to-actor communication events
Actor snapshot changes

When you pass in the inspect option to the actor options in XState’s createActor(machine, options) function, it will automatically send all of these inspection events.
For usage with other state management solutions, you can manually send inspection events using the following methods:

inspector.actor(actor, snapshot, info) - send actor creation events
inspector.event(actor, event, info) - send actor-to-actor communication events
inspector.snapshot(actor, snapshot, info) - send actor snapshot changes

import { createBrowserInspector } from '@statelyai/inspect';const inspector = createBrowserInspector();// Imagine a todo app...inspector.actor('todos');// When a todo is createdinspector.actor('todo-1', {  context: { status: 'active' }});// When a user completes a todoinspector.event('todo-1', { type: 'todo.complete' });// When a todo changesinspector.snapshot('todo-1', {  context: { status: 'completed' }});// When the todos actor (not the user) sends an event to a todoinspector.event('todo-1', { type: 'todo.update' }, {  source: 'todos'});// ... etc.
The three types of inspection events contain everything that Stately Inspector needs to generate two kinds of real-time diagrams automatically:

State machine diagrams (if a state machine definition is provided)
Sequence diagrams


Developer toolsThe XState developer tools currently only work for XState version 4. Typegen is not supported in XState version 5.
Find more about our XState CLI (Command Line Interface) below. We plan to make extensions for more IDEs (Integrated Development Environments) in the future.
Read about our XState VS Code extension on its own page.
XState CLI (Command Line Interface)​
The @xstate/cli (Command Line Interface) package contains commands for running typegen. The package is small right now, but we plan to add more features.
Installation​
Run npm install @xstate/cli.
Commands​
xstate typegen <files>​
Use the following command to run the typegen against a glob.
xstate typegen "src/**/*.ts?(x)"
Running typegen will scan every targeted file and generate a typegen file to accompany it. It will also import the typegen into your file, as described in our typegen documentation.
Ensure you wrap your glob in quotes for correct execution. If you don’t wrap the glob in quotes, it will be interpreted as a list of files, not a glob, which will give unexpected results.
Options​
xstate typegen "src/**/*.ts?(x)" --watch
Runs the task on a watch, monitoring for changed files and running the typegen script against them.

GlossaryThis glossary is an alphabetical guide to the most common terms in statecharts and state machines.
Looking for more detailed information on these concepts? Read the introduction to state machines and statecharts.
Actions​
An action is an effect that is executed during a state transition. Actions are “fire-and-forget effects”; once the machine has fired the action, it moves on and forgets the action.
Actors​
When you run a state machine, it becomes an actor, which is a running process that can receive events, send events, and change its behavior based on the events it receives, which can cause effects outside of the actor.
After transitions​
See delayed transitions.
Always transitions​
See eventless transitions.
Compound states​
See parent and child states.
Context​
Context is the place that contextual data is stored in a state machine actor.
Delayed transitions​
Delayed transitions are transitions that only happen after a specified interval of time. If another event happens before the end of the timer, the transition doesn’t complete. Delayed transitions are labeled “after” and often referred to as “after” transitions.
Eventless transitions​
Eventless transitions are transitions without events. These transitions are always taken after any transition in their state is enabled. No event is necessary to trigger the transition. Eventless transitions are labeled “always” and often referred to as “always” transitions.
Final state​
When a machine reaches the final state, it can no longer receive any events, and anything running inside it is canceled and cleaned up. A machine can have multiple final states or no final states.
Guards​
A guard is a condition that the machine checks when it goes through an event. If the condition is true, the machine follows the transition to the next state. If the condition is false, the machine follows the rest of the conditions to the next state. Any transition can be a guarded transition.
History state​
A history state returns the parent state to its most recently active child state.
Initial state​
When a state machine starts, it enters the initial state first. A machine can only have one top-level initial state.
Invoked actors​
An invoked actor is an actor that can execute its own actions and communicate with the machine. These invoked actors are started in a state and stopped when the state is exited.
Parallel states​
A parallel state is a state separated into multiple regions of child states, where each region is active simultaneously.
Parent and child states​
States can contain more states, also known as child states. These child states are only active when the parent state is active. Child states are nested inside their parent states. Parent states are also known as compound states.
States​
A state describes the status of the machine. A state can be as simple as active and inactive. These states are finite; the machine can only move through the pre-defined states. A state machine can only be in one state at a time.
Statecharts​
Statecharts are a visual extension to state machines enabling you to model more complex logic, including hierarchy, concurrency, and communication.
State machines​
A state machine is a model that describes how the state of a process transitions to another state when an event occurs. State machines make building reliable software easier because they prevent impossible states and undesired transitions. When you run a state machine, it becomes an actor.
Transitions and events​
A machine moves from state to state through transitions. Transitions are caused by events; when an event happens, the machine transitions to the next state. Transitions are “deterministic”; each combination of state and event always points to the same next state.

